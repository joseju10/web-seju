{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JoseJu En C$digo Me Presento Soy Jos\u00e9 Juan Herv\u00e1s Carrasco, graduado en Administraci\u00f3n de Sistemas Inform\u00e1ticos en Red, con una s\u00f3lida formaci\u00f3n en la gesti\u00f3n y mantenimiento de infraestructuras tecnol\u00f3gicas. Mi preparaci\u00f3n acad\u00e9mica me ha proporcionado una base robusta en la administraci\u00f3n de sistemas operativos, virtualizaci\u00f3n, bases de datos, redes y seguridad, as\u00ed como en el desarrollo y despliegue de aplicaciones web. Durante mi formaci\u00f3n, he desarrollado habilidades en una amplia gama de tecnolog\u00edas y herramientas. En el \u00e1mbito de los sistemas operativos, tengo experiencia en GNU/Linux (Debian, Ubuntu, RHEL, CentOS, Fedora) y Windows (7, 8, 10, 2008, 2012, 2016). En cuanto a virtualizaci\u00f3n y contenedores, he trabajado con LXC, VMware, Docker, KVM y VirtualBox. Adem\u00e1s, tengo conocimientos en entornos de nube como OpenStack y herramientas de gesti\u00f3n como Foreman, Ansible, Vagrant, Katello y Puppet. En el \u00e1rea de bases de datos, manejo SQL y PL/SQL, y he trabajado con sistemas como Oracle, MySQL, PostgreSQL y MongoDB. Mi experiencia en administraci\u00f3n de redes abarca desde la configuraci\u00f3n de DNS, DHCP y servicios web, hasta la gesti\u00f3n de firewalls, correo electr\u00f3nico, ficheros en red, acceso remoto, autenticaci\u00f3n y autorizaci\u00f3n, VLAN, Port Trunking y dispositivos Cisco. Tambi\u00e9n estoy familiarizado con tecnolog\u00edas de cifrado y seguridad como OpenSSL, GPG y OpenVPN, as\u00ed como con el despliegue y administraci\u00f3n de redes WiFi e IPv6. Adem\u00e1s, he adquirido competencias en lenguajes de programaci\u00f3n y desarrollo web como PHP, Java y Python, utilizando frameworks como Django. He trabajado en proyectos colaborativos utilizando herramientas de gesti\u00f3n de proyectos como Redmine, Trello y Jira, lo que me ha permitido desarrollar una fuerte capacidad para el trabajo en equipo y la gesti\u00f3n eficaz del tiempo. Mi experiencia en infraestructura tecnol\u00f3gica tambi\u00e9n incluye el manejo de almacenamiento avanzado con tecnolog\u00edas como RAID, LVM e iSCSI, y la gesti\u00f3n de versiones y control de c\u00f3digo fuente utilizando git y GitHub. Tengo habilidades en scripting con bash, as\u00ed como en el manejo de APIs RESTful, XML, JSON y YAML. Estoy buscando oportunidades laborales en el campo de la administraci\u00f3n de sistemas y redes, donde pueda aplicar mis conocimientos y habilidades para contribuir al \u00e9xito de la empresa y continuar desarroll\u00e1ndome profesionalmente. Soy una persona proactiva, comprometida y con gran capacidad para aprender r\u00e1pidamente nuevas tecnolog\u00edas y adaptarme a diferentes entornos de trabajo. Mi objetivo es seguir expandiendo mis habilidades y conocimientos en este campo en constante evoluci\u00f3n, aportando valor a mi lugar de trabajo con un enfoque innovador y una actitud positiva hacia los desaf\u00edos tecnol\u00f3gicos. Habilidades Habilidad Descripci\u00f3n GNU/Linux Debian, Ubuntu, RHEL, CentOS Windows Versiones 7, 8, 10, Server 2008, Server 2012, Server 2016 Virtualizaci\u00f3n LXC, VMware, Docker, KVM, VirtualBox Cloud OpenStack, Foreman, AWS Automatizaci\u00f3n Ansible, Vagrant, Katello, Puppet Bases de Datos Oracle, MySQL, PostgreSQL, MongoDB, DynamoDB Seguridad OpenSSL, GPG, OpenVPN Redes WiFi, IPv4, IPv6, Cisco, GNS3, DNS, DHCP, Web, Firewall Programaci\u00f3n PHP, JavaScript, Python, Django, PLSQL, bash Gesti\u00f3n de Proyectos Redmine, Trello, Jira Ofim\u00e1tica LibreOffice, Microsoft365 Almacenamiento RAID, LVM, iSCSI Control de Versiones Git, GitHub APIs RESTful, XML, JSON, YAML Tecnolog\u00edas de Red WDM, SDH, PDH, RDN Sistemas de supervisi\u00f3n SETIS, IOT","title":"Principal"},{"location":"#joseju-en-cdigo","text":"","title":"JoseJu En C$digo"},{"location":"#me-presento","text":"Soy Jos\u00e9 Juan Herv\u00e1s Carrasco, graduado en Administraci\u00f3n de Sistemas Inform\u00e1ticos en Red, con una s\u00f3lida formaci\u00f3n en la gesti\u00f3n y mantenimiento de infraestructuras tecnol\u00f3gicas. Mi preparaci\u00f3n acad\u00e9mica me ha proporcionado una base robusta en la administraci\u00f3n de sistemas operativos, virtualizaci\u00f3n, bases de datos, redes y seguridad, as\u00ed como en el desarrollo y despliegue de aplicaciones web. Durante mi formaci\u00f3n, he desarrollado habilidades en una amplia gama de tecnolog\u00edas y herramientas. En el \u00e1mbito de los sistemas operativos, tengo experiencia en GNU/Linux (Debian, Ubuntu, RHEL, CentOS, Fedora) y Windows (7, 8, 10, 2008, 2012, 2016). En cuanto a virtualizaci\u00f3n y contenedores, he trabajado con LXC, VMware, Docker, KVM y VirtualBox. Adem\u00e1s, tengo conocimientos en entornos de nube como OpenStack y herramientas de gesti\u00f3n como Foreman, Ansible, Vagrant, Katello y Puppet. En el \u00e1rea de bases de datos, manejo SQL y PL/SQL, y he trabajado con sistemas como Oracle, MySQL, PostgreSQL y MongoDB. Mi experiencia en administraci\u00f3n de redes abarca desde la configuraci\u00f3n de DNS, DHCP y servicios web, hasta la gesti\u00f3n de firewalls, correo electr\u00f3nico, ficheros en red, acceso remoto, autenticaci\u00f3n y autorizaci\u00f3n, VLAN, Port Trunking y dispositivos Cisco. Tambi\u00e9n estoy familiarizado con tecnolog\u00edas de cifrado y seguridad como OpenSSL, GPG y OpenVPN, as\u00ed como con el despliegue y administraci\u00f3n de redes WiFi e IPv6. Adem\u00e1s, he adquirido competencias en lenguajes de programaci\u00f3n y desarrollo web como PHP, Java y Python, utilizando frameworks como Django. He trabajado en proyectos colaborativos utilizando herramientas de gesti\u00f3n de proyectos como Redmine, Trello y Jira, lo que me ha permitido desarrollar una fuerte capacidad para el trabajo en equipo y la gesti\u00f3n eficaz del tiempo. Mi experiencia en infraestructura tecnol\u00f3gica tambi\u00e9n incluye el manejo de almacenamiento avanzado con tecnolog\u00edas como RAID, LVM e iSCSI, y la gesti\u00f3n de versiones y control de c\u00f3digo fuente utilizando git y GitHub. Tengo habilidades en scripting con bash, as\u00ed como en el manejo de APIs RESTful, XML, JSON y YAML. Estoy buscando oportunidades laborales en el campo de la administraci\u00f3n de sistemas y redes, donde pueda aplicar mis conocimientos y habilidades para contribuir al \u00e9xito de la empresa y continuar desarroll\u00e1ndome profesionalmente. Soy una persona proactiva, comprometida y con gran capacidad para aprender r\u00e1pidamente nuevas tecnolog\u00edas y adaptarme a diferentes entornos de trabajo. Mi objetivo es seguir expandiendo mis habilidades y conocimientos en este campo en constante evoluci\u00f3n, aportando valor a mi lugar de trabajo con un enfoque innovador y una actitud positiva hacia los desaf\u00edos tecnol\u00f3gicos.","title":"Me Presento"},{"location":"#habilidades","text":"Habilidad Descripci\u00f3n GNU/Linux Debian, Ubuntu, RHEL, CentOS Windows Versiones 7, 8, 10, Server 2008, Server 2012, Server 2016 Virtualizaci\u00f3n LXC, VMware, Docker, KVM, VirtualBox Cloud OpenStack, Foreman, AWS Automatizaci\u00f3n Ansible, Vagrant, Katello, Puppet Bases de Datos Oracle, MySQL, PostgreSQL, MongoDB, DynamoDB Seguridad OpenSSL, GPG, OpenVPN Redes WiFi, IPv4, IPv6, Cisco, GNS3, DNS, DHCP, Web, Firewall Programaci\u00f3n PHP, JavaScript, Python, Django, PLSQL, bash Gesti\u00f3n de Proyectos Redmine, Trello, Jira Ofim\u00e1tica LibreOffice, Microsoft365 Almacenamiento RAID, LVM, iSCSI Control de Versiones Git, GitHub APIs RESTful, XML, JSON, YAML Tecnolog\u00edas de Red WDM, SDH, PDH, RDN Sistemas de supervisi\u00f3n SETIS, IOT","title":"Habilidades"},{"location":"bbdd/bbdd/","text":"Sistemas Gestores de Bases de Datos Los Sistemas Gestores de Bases de Datos (SGBD) son herramientas fundamentales en el mundo de la inform\u00e1tica y la gesti\u00f3n de datos. Su principal funci\u00f3n es facilitar la creaci\u00f3n, manipulaci\u00f3n y administraci\u00f3n de bases de datos, que son colecciones organizadas de informaci\u00f3n. Un SGBD permite a los usuarios y aplicaciones interactuar con los datos de manera eficiente y segura. Existen diferentes tipos de SGBD, incluyendo: SGBD Relacionales: Utilizan un modelo de datos basado en tablas, donde la informaci\u00f3n se organiza en filas y columnas. Ejemplos populares incluyen MySQL, PostgreSQL y Oracle. SGBD NoSQL: Dise\u00f1ados para manejar grandes vol\u00famenes de datos no estructurados o semi-estructurados. Ejemplos incluyen MongoDB y Cassandra. SGBD en la Nube: Proporcionan servicios de base de datos a trav\u00e9s de la nube, permitiendo escalabilidad y flexibilidad. Ejemplos son Amazon RDS y Google Cloud Firestore. Los SGBD ofrecen diversas caracter\u00edsticas que facilitan la administraci\u00f3n de datos, como: Integridad de los datos: Aseguran que los datos sean precisos y consistentes. Seguridad: Controlan el acceso y protegen la informaci\u00f3n sensible. Consultas: Permiten la recuperaci\u00f3n de datos a trav\u00e9s de lenguajes de consulta como SQL. Transacciones: Garantizan que las operaciones de datos se realicen de manera confiable. En un entorno empresarial, los SGBD son esenciales para la toma de decisiones informadas, el an\u00e1lisis de datos y la optimizaci\u00f3n de procesos. A medida que la cantidad de datos generados contin\u00faa creciendo, la comprensi\u00f3n y gesti\u00f3n eficaz de estos sistemas se vuelve cada vez m\u00e1s cr\u00edtica. SGBD Relacionales Los SGBD Relacionales son una categor\u00eda de sistemas de gesti\u00f3n de bases de datos que organizan la informaci\u00f3n en estructuras tabulares, es decir, en tablas compuestas por filas y columnas. Esta organizaci\u00f3n permite la representaci\u00f3n y manipulaci\u00f3n eficiente de datos, y est\u00e1 basada en el modelo relacional propuesto por Edgar F. Codd en 1970. Principios Fundamentales Estos principios permiten mantener la organizaci\u00f3n, coherencia y precisi\u00f3n de los datos dentro de un SGBD Relacional. Modelo de Datos Relacional: La informaci\u00f3n se organiza en tablas, donde cada tabla representa una entidad (por ejemplo, \"Clientes\", \"Productos\"). Cada fila de una tabla corresponde a un registro \u00fanico, mientras que cada columna representa un atributo de esa entidad (por ejemplo, nombre, precio, direcci\u00f3n). Llaves Primarias y For\u00e1neas: Llave Primaria: Un identificador \u00fanico para cada fila en una tabla. Asegura que no haya duplicados en la misma tabla. Llave For\u00e1nea: Un campo que establece una relaci\u00f3n con la llave primaria de otra tabla, permitiendo la vinculaci\u00f3n entre diferentes entidades. Integridad de los Datos: Integridad de Entidad: Asegura que cada fila tenga un identificador \u00fanico (llave primaria). Integridad Referencial: Asegura que las relaciones entre tablas sean v\u00e1lidas, impidiendo que se introduzcan registros en una tabla que hagan referencia a valores no existentes en otra tabla. Lenguaje de Consulta Estructurado (SQL) El lenguaje SQL es el est\u00e1ndar para interactuar con bases de datos relacionales. Permite realizar diversas operaciones, como: Consultas (SELECT): Recuperar datos de una o m\u00e1s tablas. Inserciones (INSERT): Agregar nuevos registros a una tabla. Actualizaciones (UPDATE): Modificar registros existentes. Eliminaciones (DELETE): Remover registros de una tabla. Definici\u00f3n de Datos (DDL): Crear o modificar estructuras de tablas y relaciones (CREATE, ALTER, DROP). Ventajas de los SGBD Relacionales Estructura Clara y Organizada: La representaci\u00f3n tabular facilita la comprensi\u00f3n y gesti\u00f3n de los datos. Flexibilidad y Escalabilidad: Permiten la adici\u00f3n de nuevas tablas y relaciones sin afectar la integridad de los datos existentes. Facilidad de Acceso y Consulta: SQL proporciona un medio poderoso y vers\u00e1til para realizar consultas complejas. Mantenimiento de la Integridad de los Datos: Las reglas de integridad ayudan a garantizar que los datos sean precisos y coherentes. Desventajas de los SGBD Relacionales Rendimiento en Grandes Vol\u00famenes de Datos: Pueden experimentar problemas de rendimiento a medida que las bases de datos crecen, especialmente en operaciones complejas. Rigidez Estructural: La estructura tabular puede ser menos flexible para ciertos tipos de datos, como datos no estructurados o semi-estructurados. Escalabilidad Horizontal Limitada: La escalabilidad horizontal (distribuci\u00f3n de datos en m\u00faltiples servidores) puede ser m\u00e1s complicada en comparaci\u00f3n con algunas bases de datos NoSQL. Casos de Uso Comunes Sistemas de Gesti\u00f3n Empresarial: ERP y CRM que requieren un manejo estructurado de datos. Aplicaciones Financieras: Gesti\u00f3n de transacciones y datos sensibles. Aplicaciones Web: Backend de aplicaciones que requieren almacenamiento de datos de usuarios, productos, etc. Ejemplos de SGBD Relacionales MySQL: Popular en aplicaciones web y desarrollo de software. PostgreSQL: Conocido por su flexibilidad y soporte de tipos de datos avanzados. Oracle Database: Utilizado en grandes corporaciones por su robustez y caracter\u00edsticas avanzadas. Microsoft SQL Server: Integrado en el ecosistema de Microsoft, popular en empresas que utilizan tecnolog\u00eda de Microsoft. Conclusi\u00f3n Los SGBD Relacionales son una base esencial para la gesti\u00f3n de datos en una amplia variedad de aplicaciones y sectores. Su estructura organizada, el uso del SQL para consultas y su enfoque en la integridad de los datos los convierten en una opci\u00f3n confiable y poderosa para el manejo de informaci\u00f3n cr\u00edtica. SGBD NoSQL Los SGBD NoSQL son una categor\u00eda de sistemas de gesti\u00f3n de bases de datos que se dise\u00f1aron para manejar grandes vol\u00famenes de datos no estructurados o semi-estructurados. A diferencia de los SGBD Relacionales, que utilizan un modelo tabular, los SGBD NoSQL ofrecen diferentes modelos de datos, como documentos, clave-valor, columnas y grafos. Principios Fundamentales Estos principios permiten a los SGBD NoSQL abordar las necesidades de las aplicaciones modernas que manejan grandes vol\u00famenes de datos y requieren flexibilidad. Modelo de Datos Flexible: NoSQL permite almacenar datos en formatos m\u00e1s variados, como documentos JSON, pares clave-valor o grafos. Esto proporciona flexibilidad para representar datos complejos y cambiantes. Escalabilidad Horizontal: Muchos SGBD NoSQL est\u00e1n dise\u00f1ados para escalar horizontalmente, lo que significa que pueden manejar m\u00e1s datos y m\u00e1s usuarios distribuyendo la carga entre m\u00faltiples servidores. Alto Rendimiento: Son capaces de manejar grandes vol\u00famenes de datos y consultas de alto rendimiento, lo que los hace ideales para aplicaciones que requieren acceso r\u00e1pido a grandes conjuntos de informaci\u00f3n. Desnormalizaci\u00f3n: En lugar de normalizar los datos en m\u00faltiples tablas, los SGBD NoSQL a menudo desnormalizan los datos para optimizar la velocidad de lectura, almacenando informaci\u00f3n relacionada en una sola estructura. Sin Esquema Estricto: No requieren un esquema fijo como los SGBD Relacionales, lo que permite a los desarrolladores modificar la estructura de los datos sin interrumpir el funcionamiento del sistema. Tipos de SGBD NoSQL Bases de Datos de Documentos: Almacenan datos en documentos JSON o BSON. Ejemplos: MongoDB, CouchDB. Bases de Datos de Clave-Valor: Almacenan datos como pares de clave y valor, ideales para aplicaciones que requieren accesos r\u00e1pidos. Ejemplos: Redis, DynamoDB. Bases de Datos de Columnas: Organizan datos en columnas en lugar de filas, optimizando el rendimiento en consultas anal\u00edticas. Ejemplos: Cassandra, HBase. Bases de Datos de Grafos: Dise\u00f1adas para almacenar y consultar relaciones complejas entre datos, representando la informaci\u00f3n en forma de grafos. Ejemplos: Neo4j, Amazon Neptune. Ventajas de los SGBD NoSQL Flexibilidad: Permiten manejar datos no estructurados y adaptarse a cambios en los requisitos del modelo de datos. Escalabilidad: Facilitan la expansi\u00f3n horizontal al agregar m\u00e1s servidores para gestionar el crecimiento de datos y usuarios. Rendimiento: Ofrecen acceso r\u00e1pido a datos y consultas eficientes, especialmente en aplicaciones con grandes vol\u00famenes de informaci\u00f3n. Manejo de Datos Diversos: Pueden almacenar diferentes tipos de datos sin necesidad de una estructura r\u00edgida. Desventajas de los SGBD NoSQL Consistencia Eventual: Muchas bases de datos NoSQL utilizan modelos de consistencia eventual, lo que puede no ser adecuado para todas las aplicaciones, especialmente aquellas que requieren transacciones ACID. Falta de Est\u00e1ndares: No hay un lenguaje de consulta est\u00e1ndar unificado como SQL, lo que puede dificultar la transici\u00f3n entre diferentes SGBD NoSQL. Curva de Aprendizaje: Puede ser m\u00e1s complejo para desarrolladores acostumbrados a la l\u00f3gica de los SGBD Relacionales. Casos de Uso Comunes Aplicaciones Web y M\u00f3viles: Para gestionar grandes vol\u00famenes de datos de usuarios, contenido y preferencias. Big Data y An\u00e1lisis de Datos: Ideal para el procesamiento y an\u00e1lisis de grandes conjuntos de datos en tiempo real. Internet de las Cosas (IoT): Para almacenar y procesar datos generados por dispositivos conectados. Conclusi\u00f3n Los SGBD NoSQL son una soluci\u00f3n poderosa y flexible para la gesti\u00f3n de datos en entornos donde la agilidad, escalabilidad y rendimiento son cr\u00edticos. Su capacidad para manejar diferentes tipos de datos y su enfoque en la escalabilidad horizontal los hacen ideales para una amplia variedad de aplicaciones modernas. SGBD en la Nube Los SGBD en la Nube son servicios de gesti\u00f3n de bases de datos que se ofrecen a trav\u00e9s de plataformas en la nube. Permiten a las organizaciones almacenar, gestionar y acceder a sus datos sin necesidad de infraestructura f\u00edsica propia, aprovechando la escalabilidad, flexibilidad y accesibilidad que ofrece la nube. Principios Fundamentales Estos principios permiten a las organizaciones aprovechar al m\u00e1ximo las ventajas de la nube en la gesti\u00f3n de datos. Modelo de Servicio: Generalmente se ofrecen en modelos de servicio como Database as a Service (DBaaS), donde el proveedor gestiona la infraestructura, el software y las actualizaciones, permitiendo a los usuarios centrarse en el desarrollo de aplicaciones. Escalabilidad Autom\u00e1tica: Permiten ajustar autom\u00e1ticamente los recursos de almacenamiento y computaci\u00f3n seg\u00fan la demanda, facilitando el manejo de picos de tr\u00e1fico sin interrupciones. Accesibilidad Global: Los datos pueden ser accedidos desde cualquier lugar con conexi\u00f3n a Internet, lo que facilita la colaboraci\u00f3n y el trabajo remoto. Seguridad y Cumplimiento: Proveedores de nube suelen ofrecer caracter\u00edsticas de seguridad avanzadas, como cifrado, autenticaci\u00f3n multifactor y copias de seguridad autom\u00e1ticas, adem\u00e1s de cumplir con normativas de protecci\u00f3n de datos. Gesti\u00f3n Simplificada: Incluyen herramientas para la administraci\u00f3n y monitoreo de bases de datos, lo que reduce la carga operativa para los equipos de TI. Tipos de SGBD en la Nube SGBD Relacionales: Como Amazon RDS y Google Cloud SQL, que ofrecen bases de datos SQL en la nube. SGBD NoSQL: Como Amazon DynamoDB y Google Cloud Firestore, que permiten manejar datos no estructurados o semi-estructurados. Data Warehouses: Como Google BigQuery y Amazon Redshift, dise\u00f1ados para an\u00e1lisis de grandes vol\u00famenes de datos. Bases de Datos de Grafos: Como Amazon Neptune, que se especializan en gestionar relaciones complejas entre datos. Ventajas de los SGBD en la Nube Reducci\u00f3n de Costos: Eliminan la necesidad de inversiones en hardware y reducen costos operativos, ya que se paga por lo que se utiliza. Escalabilidad y Flexibilidad: Permiten ajustar los recursos de manera din\u00e1mica seg\u00fan las necesidades del negocio. Alta Disponibilidad y Resiliencia: Proveedores de nube suelen ofrecer redundancia y recuperaci\u00f3n ante desastres, asegurando que los datos est\u00e9n siempre disponibles. Innovaci\u00f3n R\u00e1pida: Facilitan la implementaci\u00f3n de nuevas tecnolog\u00edas y actualizaciones de forma \u00e1gil. Desventajas de los SGBD en la Nube Dependencia del Proveedor: La elecci\u00f3n de un proveedor de nube puede generar dependencia, dificultando la migraci\u00f3n a otra soluci\u00f3n. Preocupaciones de Seguridad: Aunque se implementan medidas de seguridad, siempre existe el riesgo de vulnerabilidades y brechas de seguridad. Costos Variables: Aunque pueden ser m\u00e1s econ\u00f3micos, los costos pueden aumentar r\u00e1pidamente si no se gestionan adecuadamente los recursos. Casos de Uso Comunes Aplicaciones Empresariales: Para gestionar datos cr\u00edticos en tiempo real. Desarrollo \u00c1gil: Permiten a los equipos de desarrollo implementar y probar aplicaciones r\u00e1pidamente. An\u00e1lisis de Datos: Utilizados para an\u00e1lisis de datos y generaci\u00f3n de informes en tiempo real. Conclusi\u00f3n Los SGBD en la Nube representan una soluci\u00f3n moderna y eficiente para la gesti\u00f3n de datos, ofreciendo flexibilidad, escalabilidad y reducci\u00f3n de costos. Su capacidad para integrarse con otras soluciones en la nube los convierte en una opci\u00f3n atractiva para organizaciones que buscan optimizar su infraestructura de datos.","title":"Introducci\u00f3n"},{"location":"bbdd/bbdd/#sistemas-gestores-de-bases-de-datos","text":"Los Sistemas Gestores de Bases de Datos (SGBD) son herramientas fundamentales en el mundo de la inform\u00e1tica y la gesti\u00f3n de datos. Su principal funci\u00f3n es facilitar la creaci\u00f3n, manipulaci\u00f3n y administraci\u00f3n de bases de datos, que son colecciones organizadas de informaci\u00f3n. Un SGBD permite a los usuarios y aplicaciones interactuar con los datos de manera eficiente y segura. Existen diferentes tipos de SGBD, incluyendo: SGBD Relacionales: Utilizan un modelo de datos basado en tablas, donde la informaci\u00f3n se organiza en filas y columnas. Ejemplos populares incluyen MySQL, PostgreSQL y Oracle. SGBD NoSQL: Dise\u00f1ados para manejar grandes vol\u00famenes de datos no estructurados o semi-estructurados. Ejemplos incluyen MongoDB y Cassandra. SGBD en la Nube: Proporcionan servicios de base de datos a trav\u00e9s de la nube, permitiendo escalabilidad y flexibilidad. Ejemplos son Amazon RDS y Google Cloud Firestore. Los SGBD ofrecen diversas caracter\u00edsticas que facilitan la administraci\u00f3n de datos, como: Integridad de los datos: Aseguran que los datos sean precisos y consistentes. Seguridad: Controlan el acceso y protegen la informaci\u00f3n sensible. Consultas: Permiten la recuperaci\u00f3n de datos a trav\u00e9s de lenguajes de consulta como SQL. Transacciones: Garantizan que las operaciones de datos se realicen de manera confiable. En un entorno empresarial, los SGBD son esenciales para la toma de decisiones informadas, el an\u00e1lisis de datos y la optimizaci\u00f3n de procesos. A medida que la cantidad de datos generados contin\u00faa creciendo, la comprensi\u00f3n y gesti\u00f3n eficaz de estos sistemas se vuelve cada vez m\u00e1s cr\u00edtica.","title":"Sistemas Gestores de Bases de Datos"},{"location":"bbdd/bbdd/#sgbd-relacionales","text":"Los SGBD Relacionales son una categor\u00eda de sistemas de gesti\u00f3n de bases de datos que organizan la informaci\u00f3n en estructuras tabulares, es decir, en tablas compuestas por filas y columnas. Esta organizaci\u00f3n permite la representaci\u00f3n y manipulaci\u00f3n eficiente de datos, y est\u00e1 basada en el modelo relacional propuesto por Edgar F. Codd en 1970.","title":"SGBD Relacionales"},{"location":"bbdd/bbdd/#principios-fundamentales","text":"Estos principios permiten mantener la organizaci\u00f3n, coherencia y precisi\u00f3n de los datos dentro de un SGBD Relacional.","title":"Principios Fundamentales"},{"location":"bbdd/bbdd/#modelo-de-datos-relacional","text":"La informaci\u00f3n se organiza en tablas, donde cada tabla representa una entidad (por ejemplo, \"Clientes\", \"Productos\"). Cada fila de una tabla corresponde a un registro \u00fanico, mientras que cada columna representa un atributo de esa entidad (por ejemplo, nombre, precio, direcci\u00f3n).","title":"Modelo de Datos Relacional:"},{"location":"bbdd/bbdd/#llaves-primarias-y-foraneas","text":"Llave Primaria: Un identificador \u00fanico para cada fila en una tabla. Asegura que no haya duplicados en la misma tabla. Llave For\u00e1nea: Un campo que establece una relaci\u00f3n con la llave primaria de otra tabla, permitiendo la vinculaci\u00f3n entre diferentes entidades.","title":"Llaves Primarias y For\u00e1neas:"},{"location":"bbdd/bbdd/#integridad-de-los-datos","text":"Integridad de Entidad: Asegura que cada fila tenga un identificador \u00fanico (llave primaria). Integridad Referencial: Asegura que las relaciones entre tablas sean v\u00e1lidas, impidiendo que se introduzcan registros en una tabla que hagan referencia a valores no existentes en otra tabla.","title":"Integridad de los Datos:"},{"location":"bbdd/bbdd/#lenguaje-de-consulta-estructurado-sql","text":"El lenguaje SQL es el est\u00e1ndar para interactuar con bases de datos relacionales. Permite realizar diversas operaciones, como: Consultas (SELECT): Recuperar datos de una o m\u00e1s tablas. Inserciones (INSERT): Agregar nuevos registros a una tabla. Actualizaciones (UPDATE): Modificar registros existentes. Eliminaciones (DELETE): Remover registros de una tabla. Definici\u00f3n de Datos (DDL): Crear o modificar estructuras de tablas y relaciones (CREATE, ALTER, DROP).","title":"Lenguaje de Consulta Estructurado (SQL)"},{"location":"bbdd/bbdd/#ventajas-de-los-sgbd-relacionales","text":"Estructura Clara y Organizada: La representaci\u00f3n tabular facilita la comprensi\u00f3n y gesti\u00f3n de los datos. Flexibilidad y Escalabilidad: Permiten la adici\u00f3n de nuevas tablas y relaciones sin afectar la integridad de los datos existentes. Facilidad de Acceso y Consulta: SQL proporciona un medio poderoso y vers\u00e1til para realizar consultas complejas. Mantenimiento de la Integridad de los Datos: Las reglas de integridad ayudan a garantizar que los datos sean precisos y coherentes.","title":"Ventajas de los SGBD Relacionales"},{"location":"bbdd/bbdd/#desventajas-de-los-sgbd-relacionales","text":"Rendimiento en Grandes Vol\u00famenes de Datos: Pueden experimentar problemas de rendimiento a medida que las bases de datos crecen, especialmente en operaciones complejas. Rigidez Estructural: La estructura tabular puede ser menos flexible para ciertos tipos de datos, como datos no estructurados o semi-estructurados. Escalabilidad Horizontal Limitada: La escalabilidad horizontal (distribuci\u00f3n de datos en m\u00faltiples servidores) puede ser m\u00e1s complicada en comparaci\u00f3n con algunas bases de datos NoSQL.","title":"Desventajas de los SGBD Relacionales"},{"location":"bbdd/bbdd/#casos-de-uso-comunes","text":"Sistemas de Gesti\u00f3n Empresarial: ERP y CRM que requieren un manejo estructurado de datos. Aplicaciones Financieras: Gesti\u00f3n de transacciones y datos sensibles. Aplicaciones Web: Backend de aplicaciones que requieren almacenamiento de datos de usuarios, productos, etc.","title":"Casos de Uso Comunes"},{"location":"bbdd/bbdd/#ejemplos-de-sgbd-relacionales","text":"MySQL: Popular en aplicaciones web y desarrollo de software. PostgreSQL: Conocido por su flexibilidad y soporte de tipos de datos avanzados. Oracle Database: Utilizado en grandes corporaciones por su robustez y caracter\u00edsticas avanzadas. Microsoft SQL Server: Integrado en el ecosistema de Microsoft, popular en empresas que utilizan tecnolog\u00eda de Microsoft.","title":"Ejemplos de SGBD Relacionales"},{"location":"bbdd/bbdd/#conclusion","text":"Los SGBD Relacionales son una base esencial para la gesti\u00f3n de datos en una amplia variedad de aplicaciones y sectores. Su estructura organizada, el uso del SQL para consultas y su enfoque en la integridad de los datos los convierten en una opci\u00f3n confiable y poderosa para el manejo de informaci\u00f3n cr\u00edtica.","title":"Conclusi\u00f3n"},{"location":"bbdd/bbdd/#sgbd-nosql","text":"Los SGBD NoSQL son una categor\u00eda de sistemas de gesti\u00f3n de bases de datos que se dise\u00f1aron para manejar grandes vol\u00famenes de datos no estructurados o semi-estructurados. A diferencia de los SGBD Relacionales, que utilizan un modelo tabular, los SGBD NoSQL ofrecen diferentes modelos de datos, como documentos, clave-valor, columnas y grafos.","title":"SGBD NoSQL"},{"location":"bbdd/bbdd/#principios-fundamentales_1","text":"Estos principios permiten a los SGBD NoSQL abordar las necesidades de las aplicaciones modernas que manejan grandes vol\u00famenes de datos y requieren flexibilidad.","title":"Principios Fundamentales"},{"location":"bbdd/bbdd/#modelo-de-datos-flexible","text":"NoSQL permite almacenar datos en formatos m\u00e1s variados, como documentos JSON, pares clave-valor o grafos. Esto proporciona flexibilidad para representar datos complejos y cambiantes.","title":"Modelo de Datos Flexible:"},{"location":"bbdd/bbdd/#escalabilidad-horizontal","text":"Muchos SGBD NoSQL est\u00e1n dise\u00f1ados para escalar horizontalmente, lo que significa que pueden manejar m\u00e1s datos y m\u00e1s usuarios distribuyendo la carga entre m\u00faltiples servidores.","title":"Escalabilidad Horizontal:"},{"location":"bbdd/bbdd/#alto-rendimiento","text":"Son capaces de manejar grandes vol\u00famenes de datos y consultas de alto rendimiento, lo que los hace ideales para aplicaciones que requieren acceso r\u00e1pido a grandes conjuntos de informaci\u00f3n.","title":"Alto Rendimiento:"},{"location":"bbdd/bbdd/#desnormalizacion","text":"En lugar de normalizar los datos en m\u00faltiples tablas, los SGBD NoSQL a menudo desnormalizan los datos para optimizar la velocidad de lectura, almacenando informaci\u00f3n relacionada en una sola estructura.","title":"Desnormalizaci\u00f3n:"},{"location":"bbdd/bbdd/#sin-esquema-estricto","text":"No requieren un esquema fijo como los SGBD Relacionales, lo que permite a los desarrolladores modificar la estructura de los datos sin interrumpir el funcionamiento del sistema.","title":"Sin Esquema Estricto:"},{"location":"bbdd/bbdd/#tipos-de-sgbd-nosql","text":"Bases de Datos de Documentos: Almacenan datos en documentos JSON o BSON. Ejemplos: MongoDB, CouchDB. Bases de Datos de Clave-Valor: Almacenan datos como pares de clave y valor, ideales para aplicaciones que requieren accesos r\u00e1pidos. Ejemplos: Redis, DynamoDB. Bases de Datos de Columnas: Organizan datos en columnas en lugar de filas, optimizando el rendimiento en consultas anal\u00edticas. Ejemplos: Cassandra, HBase. Bases de Datos de Grafos: Dise\u00f1adas para almacenar y consultar relaciones complejas entre datos, representando la informaci\u00f3n en forma de grafos. Ejemplos: Neo4j, Amazon Neptune.","title":"Tipos de SGBD NoSQL"},{"location":"bbdd/bbdd/#ventajas-de-los-sgbd-nosql","text":"Flexibilidad: Permiten manejar datos no estructurados y adaptarse a cambios en los requisitos del modelo de datos. Escalabilidad: Facilitan la expansi\u00f3n horizontal al agregar m\u00e1s servidores para gestionar el crecimiento de datos y usuarios. Rendimiento: Ofrecen acceso r\u00e1pido a datos y consultas eficientes, especialmente en aplicaciones con grandes vol\u00famenes de informaci\u00f3n. Manejo de Datos Diversos: Pueden almacenar diferentes tipos de datos sin necesidad de una estructura r\u00edgida.","title":"Ventajas de los SGBD NoSQL"},{"location":"bbdd/bbdd/#desventajas-de-los-sgbd-nosql","text":"Consistencia Eventual: Muchas bases de datos NoSQL utilizan modelos de consistencia eventual, lo que puede no ser adecuado para todas las aplicaciones, especialmente aquellas que requieren transacciones ACID. Falta de Est\u00e1ndares: No hay un lenguaje de consulta est\u00e1ndar unificado como SQL, lo que puede dificultar la transici\u00f3n entre diferentes SGBD NoSQL. Curva de Aprendizaje: Puede ser m\u00e1s complejo para desarrolladores acostumbrados a la l\u00f3gica de los SGBD Relacionales.","title":"Desventajas de los SGBD NoSQL"},{"location":"bbdd/bbdd/#casos-de-uso-comunes_1","text":"Aplicaciones Web y M\u00f3viles: Para gestionar grandes vol\u00famenes de datos de usuarios, contenido y preferencias. Big Data y An\u00e1lisis de Datos: Ideal para el procesamiento y an\u00e1lisis de grandes conjuntos de datos en tiempo real. Internet de las Cosas (IoT): Para almacenar y procesar datos generados por dispositivos conectados.","title":"Casos de Uso Comunes"},{"location":"bbdd/bbdd/#conclusion_1","text":"Los SGBD NoSQL son una soluci\u00f3n poderosa y flexible para la gesti\u00f3n de datos en entornos donde la agilidad, escalabilidad y rendimiento son cr\u00edticos. Su capacidad para manejar diferentes tipos de datos y su enfoque en la escalabilidad horizontal los hacen ideales para una amplia variedad de aplicaciones modernas.","title":"Conclusi\u00f3n"},{"location":"bbdd/bbdd/#sgbd-en-la-nube","text":"Los SGBD en la Nube son servicios de gesti\u00f3n de bases de datos que se ofrecen a trav\u00e9s de plataformas en la nube. Permiten a las organizaciones almacenar, gestionar y acceder a sus datos sin necesidad de infraestructura f\u00edsica propia, aprovechando la escalabilidad, flexibilidad y accesibilidad que ofrece la nube.","title":"SGBD en la Nube"},{"location":"bbdd/bbdd/#principios-fundamentales_2","text":"Estos principios permiten a las organizaciones aprovechar al m\u00e1ximo las ventajas de la nube en la gesti\u00f3n de datos.","title":"Principios Fundamentales"},{"location":"bbdd/bbdd/#modelo-de-servicio","text":"Generalmente se ofrecen en modelos de servicio como Database as a Service (DBaaS), donde el proveedor gestiona la infraestructura, el software y las actualizaciones, permitiendo a los usuarios centrarse en el desarrollo de aplicaciones.","title":"Modelo de Servicio:"},{"location":"bbdd/bbdd/#escalabilidad-automatica","text":"Permiten ajustar autom\u00e1ticamente los recursos de almacenamiento y computaci\u00f3n seg\u00fan la demanda, facilitando el manejo de picos de tr\u00e1fico sin interrupciones.","title":"Escalabilidad Autom\u00e1tica:"},{"location":"bbdd/bbdd/#accesibilidad-global","text":"Los datos pueden ser accedidos desde cualquier lugar con conexi\u00f3n a Internet, lo que facilita la colaboraci\u00f3n y el trabajo remoto.","title":"Accesibilidad Global:"},{"location":"bbdd/bbdd/#seguridad-y-cumplimiento","text":"Proveedores de nube suelen ofrecer caracter\u00edsticas de seguridad avanzadas, como cifrado, autenticaci\u00f3n multifactor y copias de seguridad autom\u00e1ticas, adem\u00e1s de cumplir con normativas de protecci\u00f3n de datos.","title":"Seguridad y Cumplimiento:"},{"location":"bbdd/bbdd/#gestion-simplificada","text":"Incluyen herramientas para la administraci\u00f3n y monitoreo de bases de datos, lo que reduce la carga operativa para los equipos de TI.","title":"Gesti\u00f3n Simplificada:"},{"location":"bbdd/bbdd/#tipos-de-sgbd-en-la-nube","text":"SGBD Relacionales: Como Amazon RDS y Google Cloud SQL, que ofrecen bases de datos SQL en la nube. SGBD NoSQL: Como Amazon DynamoDB y Google Cloud Firestore, que permiten manejar datos no estructurados o semi-estructurados. Data Warehouses: Como Google BigQuery y Amazon Redshift, dise\u00f1ados para an\u00e1lisis de grandes vol\u00famenes de datos. Bases de Datos de Grafos: Como Amazon Neptune, que se especializan en gestionar relaciones complejas entre datos.","title":"Tipos de SGBD en la Nube"},{"location":"bbdd/bbdd/#ventajas-de-los-sgbd-en-la-nube","text":"Reducci\u00f3n de Costos: Eliminan la necesidad de inversiones en hardware y reducen costos operativos, ya que se paga por lo que se utiliza. Escalabilidad y Flexibilidad: Permiten ajustar los recursos de manera din\u00e1mica seg\u00fan las necesidades del negocio. Alta Disponibilidad y Resiliencia: Proveedores de nube suelen ofrecer redundancia y recuperaci\u00f3n ante desastres, asegurando que los datos est\u00e9n siempre disponibles. Innovaci\u00f3n R\u00e1pida: Facilitan la implementaci\u00f3n de nuevas tecnolog\u00edas y actualizaciones de forma \u00e1gil.","title":"Ventajas de los SGBD en la Nube"},{"location":"bbdd/bbdd/#desventajas-de-los-sgbd-en-la-nube","text":"Dependencia del Proveedor: La elecci\u00f3n de un proveedor de nube puede generar dependencia, dificultando la migraci\u00f3n a otra soluci\u00f3n. Preocupaciones de Seguridad: Aunque se implementan medidas de seguridad, siempre existe el riesgo de vulnerabilidades y brechas de seguridad. Costos Variables: Aunque pueden ser m\u00e1s econ\u00f3micos, los costos pueden aumentar r\u00e1pidamente si no se gestionan adecuadamente los recursos.","title":"Desventajas de los SGBD en la Nube"},{"location":"bbdd/bbdd/#casos-de-uso-comunes_2","text":"Aplicaciones Empresariales: Para gestionar datos cr\u00edticos en tiempo real. Desarrollo \u00c1gil: Permiten a los equipos de desarrollo implementar y probar aplicaciones r\u00e1pidamente. An\u00e1lisis de Datos: Utilizados para an\u00e1lisis de datos y generaci\u00f3n de informes en tiempo real.","title":"Casos de Uso Comunes"},{"location":"bbdd/bbdd/#conclusion_2","text":"Los SGBD en la Nube representan una soluci\u00f3n moderna y eficiente para la gesti\u00f3n de datos, ofreciendo flexibilidad, escalabilidad y reducci\u00f3n de costos. Su capacidad para integrarse con otras soluciones en la nube los convierte en una opci\u00f3n atractiva para organizaciones que buscan optimizar su infraestructura de datos.","title":"Conclusi\u00f3n"},{"location":"bbdd/sgbd-norel/oracle/oracle/","text":"Definici\u00f3n Oracle Database es un sistema gestor de bases de datos relacional (SGBD) desarrollado por Oracle Corporation. Es conocido por su robustez, escalabilidad y amplia gama de caracter\u00edsticas que lo convierten en una opci\u00f3n popular para empresas de todos los tama\u00f1os. Caracter\u00edsticas Principales Modelo Relacional: Oracle utiliza un modelo relacional, lo que significa que los datos se organizan en tablas con filas y columnas. Esto permite una f\u00e1cil estructuraci\u00f3n y recuperaci\u00f3n de datos. Transacciones Seguras: Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad), asegurando que las operaciones sean completas y fiables. Escalabilidad: Oracle puede manejar grandes vol\u00famenes de datos y un alto n\u00famero de usuarios concurrentes, lo que lo hace adecuado para aplicaciones empresariales cr\u00edticas. Alta Disponibilidad: Incluye caracter\u00edsticas como Oracle Real Application Clusters (RAC), que permiten que m\u00faltiples servidores trabajen juntos, asegurando que la base de datos est\u00e9 disponible incluso si uno de los servidores falla. Seguridad Avanzada: Ofrece robustas caracter\u00edsticas de seguridad, incluyendo autenticaci\u00f3n de usuarios, encriptaci\u00f3n de datos y control de acceso basado en roles. Herramientas de Desarrollo: Proporciona herramientas como Oracle SQL Developer y Oracle Application Express (APEX) para facilitar el desarrollo y la gesti\u00f3n de bases de datos. Compatibilidad con NoSQL: A trav\u00e9s de Oracle Database 21c y versiones posteriores, se integra con modelos de datos NoSQL, permitiendo trabajar con documentos JSON y datos de grafos. Soporte para SQL y PL/SQL: Utiliza SQL como lenguaje de consulta est\u00e1ndar y PL/SQL (Procedural Language/SQL) para el desarrollo de aplicaciones, permitiendo la programaci\u00f3n de l\u00f3gica compleja en la base de datos. Casos de Uso Aplicaciones Empresariales: Ideal para aplicaciones cr\u00edticas en sectores como finanzas, salud y telecomunicaciones. Data Warehousing: Adecuado para la consolidaci\u00f3n y an\u00e1lisis de grandes vol\u00famenes de datos. E-commerce: Soporta plataformas de comercio electr\u00f3nico con alta carga de transacciones. Conclusi\u00f3n Oracle Database es una soluci\u00f3n poderosa y vers\u00e1til para la gesti\u00f3n de datos en entornos empresariales. Su capacidad para manejar grandes vol\u00famenes de informaci\u00f3n, junto con caracter\u00edsticas de seguridad y disponibilidad, lo convierte en una opci\u00f3n preferida para organizaciones que requieren un SGBD robusto y confiable.","title":"Oracle"},{"location":"bbdd/sgbd-norel/oracle/oracle/#definicion","text":"Oracle Database es un sistema gestor de bases de datos relacional (SGBD) desarrollado por Oracle Corporation. Es conocido por su robustez, escalabilidad y amplia gama de caracter\u00edsticas que lo convierten en una opci\u00f3n popular para empresas de todos los tama\u00f1os.","title":"Definici\u00f3n"},{"location":"bbdd/sgbd-norel/oracle/oracle/#caracteristicas-principales","text":"Modelo Relacional: Oracle utiliza un modelo relacional, lo que significa que los datos se organizan en tablas con filas y columnas. Esto permite una f\u00e1cil estructuraci\u00f3n y recuperaci\u00f3n de datos. Transacciones Seguras: Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad), asegurando que las operaciones sean completas y fiables. Escalabilidad: Oracle puede manejar grandes vol\u00famenes de datos y un alto n\u00famero de usuarios concurrentes, lo que lo hace adecuado para aplicaciones empresariales cr\u00edticas. Alta Disponibilidad: Incluye caracter\u00edsticas como Oracle Real Application Clusters (RAC), que permiten que m\u00faltiples servidores trabajen juntos, asegurando que la base de datos est\u00e9 disponible incluso si uno de los servidores falla. Seguridad Avanzada: Ofrece robustas caracter\u00edsticas de seguridad, incluyendo autenticaci\u00f3n de usuarios, encriptaci\u00f3n de datos y control de acceso basado en roles. Herramientas de Desarrollo: Proporciona herramientas como Oracle SQL Developer y Oracle Application Express (APEX) para facilitar el desarrollo y la gesti\u00f3n de bases de datos. Compatibilidad con NoSQL: A trav\u00e9s de Oracle Database 21c y versiones posteriores, se integra con modelos de datos NoSQL, permitiendo trabajar con documentos JSON y datos de grafos. Soporte para SQL y PL/SQL: Utiliza SQL como lenguaje de consulta est\u00e1ndar y PL/SQL (Procedural Language/SQL) para el desarrollo de aplicaciones, permitiendo la programaci\u00f3n de l\u00f3gica compleja en la base de datos.","title":"Caracter\u00edsticas Principales"},{"location":"bbdd/sgbd-norel/oracle/oracle/#casos-de-uso","text":"Aplicaciones Empresariales: Ideal para aplicaciones cr\u00edticas en sectores como finanzas, salud y telecomunicaciones. Data Warehousing: Adecuado para la consolidaci\u00f3n y an\u00e1lisis de grandes vol\u00famenes de datos. E-commerce: Soporta plataformas de comercio electr\u00f3nico con alta carga de transacciones.","title":"Casos de Uso"},{"location":"bbdd/sgbd-norel/oracle/oracle/#conclusion","text":"Oracle Database es una soluci\u00f3n poderosa y vers\u00e1til para la gesti\u00f3n de datos en entornos empresariales. Su capacidad para manejar grandes vol\u00famenes de informaci\u00f3n, junto con caracter\u00edsticas de seguridad y disponibilidad, lo convierte en una opci\u00f3n preferida para organizaciones que requieren un SGBD robusto y confiable.","title":"Conclusi\u00f3n"},{"location":"bbdd/sgbd-rel/mariadb/oracle/","text":"Definici\u00f3n Oracle Database es un sistema gestor de bases de datos relacional (SGBD) desarrollado por Oracle Corporation. Es conocido por su robustez, escalabilidad y amplia gama de caracter\u00edsticas que lo convierten en una opci\u00f3n popular para empresas de todos los tama\u00f1os. Caracter\u00edsticas Principales Modelo Relacional: Oracle utiliza un modelo relacional, lo que significa que los datos se organizan en tablas con filas y columnas. Esto permite una f\u00e1cil estructuraci\u00f3n y recuperaci\u00f3n de datos. Transacciones Seguras: Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad), asegurando que las operaciones sean completas y fiables. Escalabilidad: Oracle puede manejar grandes vol\u00famenes de datos y un alto n\u00famero de usuarios concurrentes, lo que lo hace adecuado para aplicaciones empresariales cr\u00edticas. Alta Disponibilidad: Incluye caracter\u00edsticas como Oracle Real Application Clusters (RAC), que permiten que m\u00faltiples servidores trabajen juntos, asegurando que la base de datos est\u00e9 disponible incluso si uno de los servidores falla. Seguridad Avanzada: Ofrece robustas caracter\u00edsticas de seguridad, incluyendo autenticaci\u00f3n de usuarios, encriptaci\u00f3n de datos y control de acceso basado en roles. Herramientas de Desarrollo: Proporciona herramientas como Oracle SQL Developer y Oracle Application Express (APEX) para facilitar el desarrollo y la gesti\u00f3n de bases de datos. Compatibilidad con NoSQL: A trav\u00e9s de Oracle Database 21c y versiones posteriores, se integra con modelos de datos NoSQL, permitiendo trabajar con documentos JSON y datos de grafos. Soporte para SQL y PL/SQL: Utiliza SQL como lenguaje de consulta est\u00e1ndar y PL/SQL (Procedural Language/SQL) para el desarrollo de aplicaciones, permitiendo la programaci\u00f3n de l\u00f3gica compleja en la base de datos. Casos de Uso Aplicaciones Empresariales: Ideal para aplicaciones cr\u00edticas en sectores como finanzas, salud y telecomunicaciones. Data Warehousing: Adecuado para la consolidaci\u00f3n y an\u00e1lisis de grandes vol\u00famenes de datos. E-commerce: Soporta plataformas de comercio electr\u00f3nico con alta carga de transacciones. Conclusi\u00f3n Oracle Database es una soluci\u00f3n poderosa y vers\u00e1til para la gesti\u00f3n de datos en entornos empresariales. Su capacidad para manejar grandes vol\u00famenes de informaci\u00f3n, junto con caracter\u00edsticas de seguridad y disponibilidad, lo convierte en una opci\u00f3n preferida para organizaciones que requieren un SGBD robusto y confiable.","title":"Oracle"},{"location":"bbdd/sgbd-rel/mariadb/oracle/#definicion","text":"Oracle Database es un sistema gestor de bases de datos relacional (SGBD) desarrollado por Oracle Corporation. Es conocido por su robustez, escalabilidad y amplia gama de caracter\u00edsticas que lo convierten en una opci\u00f3n popular para empresas de todos los tama\u00f1os.","title":"Definici\u00f3n"},{"location":"bbdd/sgbd-rel/mariadb/oracle/#caracteristicas-principales","text":"Modelo Relacional: Oracle utiliza un modelo relacional, lo que significa que los datos se organizan en tablas con filas y columnas. Esto permite una f\u00e1cil estructuraci\u00f3n y recuperaci\u00f3n de datos. Transacciones Seguras: Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad), asegurando que las operaciones sean completas y fiables. Escalabilidad: Oracle puede manejar grandes vol\u00famenes de datos y un alto n\u00famero de usuarios concurrentes, lo que lo hace adecuado para aplicaciones empresariales cr\u00edticas. Alta Disponibilidad: Incluye caracter\u00edsticas como Oracle Real Application Clusters (RAC), que permiten que m\u00faltiples servidores trabajen juntos, asegurando que la base de datos est\u00e9 disponible incluso si uno de los servidores falla. Seguridad Avanzada: Ofrece robustas caracter\u00edsticas de seguridad, incluyendo autenticaci\u00f3n de usuarios, encriptaci\u00f3n de datos y control de acceso basado en roles. Herramientas de Desarrollo: Proporciona herramientas como Oracle SQL Developer y Oracle Application Express (APEX) para facilitar el desarrollo y la gesti\u00f3n de bases de datos. Compatibilidad con NoSQL: A trav\u00e9s de Oracle Database 21c y versiones posteriores, se integra con modelos de datos NoSQL, permitiendo trabajar con documentos JSON y datos de grafos. Soporte para SQL y PL/SQL: Utiliza SQL como lenguaje de consulta est\u00e1ndar y PL/SQL (Procedural Language/SQL) para el desarrollo de aplicaciones, permitiendo la programaci\u00f3n de l\u00f3gica compleja en la base de datos.","title":"Caracter\u00edsticas Principales"},{"location":"bbdd/sgbd-rel/mariadb/oracle/#casos-de-uso","text":"Aplicaciones Empresariales: Ideal para aplicaciones cr\u00edticas en sectores como finanzas, salud y telecomunicaciones. Data Warehousing: Adecuado para la consolidaci\u00f3n y an\u00e1lisis de grandes vol\u00famenes de datos. E-commerce: Soporta plataformas de comercio electr\u00f3nico con alta carga de transacciones.","title":"Casos de Uso"},{"location":"bbdd/sgbd-rel/mariadb/oracle/#conclusion","text":"Oracle Database es una soluci\u00f3n poderosa y vers\u00e1til para la gesti\u00f3n de datos en entornos empresariales. Su capacidad para manejar grandes vol\u00famenes de informaci\u00f3n, junto con caracter\u00edsticas de seguridad y disponibilidad, lo convierte en una opci\u00f3n preferida para organizaciones que requieren un SGBD robusto y confiable.","title":"Conclusi\u00f3n"},{"location":"bbdd/sgbd-rel/oracle/consultas/","text":"Ejercicios de Consultas SQL Esquema Base de datos Dada la siguiente base de datos realizaremos una serie de consultas.: Ejercicios B\u00e1sicos Obtener todos los equipos Escribe una consulta para listar todos los nombres de los equipos en la tabla Equipos. SQL> SELECT nombre 2 FROM equipos; NOMBRE -------------------------------------------------- FC Barcelona Real Madrid Manchester United Bayern Munich SELECT nombre: SELECT: Indica que estamos interesados en obtener datos de la base de datos. nombre: Especifica la columna que deseamos seleccionar. En este caso, se refiere a la columna que contiene los nombres de los equipos. FROM equipos: FROM: Especifica de qu\u00e9 tabla queremos extraer la informaci\u00f3n. equipos: Indica que la consulta debe buscar los datos en la tabla llamada equipos. Contar camisetas en stock Realiza una consulta que cuente cu\u00e1ntas camisetas hay en stock para cada equipo. SQL> SELECT e.nombre AS equipo, SUM(c.stock) AS total_camisetas 2 FROM Equipos e 3 JOIN Camisetas c ON e.id_equipo = c.id_equipo 4 GROUP BY e.nombre; EQUIPO TOTAL_CAMISETAS -------------------------------------------------- --------------- Real Madrid 150 Bayern Munich 50 FC Barcelona 100 Manchester United 200 SELECT e.nombre AS equipo, SUM(c.stock) AS total_camisetas: SELECT: Esta cl\u00e1usula indica qu\u00e9 columnas deseas ver en el resultado de la consulta. e.nombre AS equipo: Aqu\u00ed estamos seleccionando el nombre del equipo (de la tabla Equipos) y le estamos dando un alias (equipo) para que sea m\u00e1s f\u00e1cil de entender en los resultados. SUM(c.stock) AS total_camisetas: Estamos usando la funci\u00f3n de agregaci\u00f3n SUM para sumar el stock de camisetas (de la tabla Camisetas). El resultado de esta suma se denomina total_camisetas. FROM Equipos e: FROM: Indica de qu\u00e9 tablas se extraer\u00e1n los datos. Equipos e: Aqu\u00ed estamos seleccionando la tabla Equipos y le estamos asignando un alias (e). Los alias son \u00fatiles para simplificar la referencia a las tablas en la consulta. JOIN Camisetas c ON e.id_equipo = c.id_equipo: JOIN: Se utiliza para combinar filas de dos o m\u00e1s tablas basadas en una relaci\u00f3n entre ellas. Camisetas c: Esta es la segunda tabla que estamos uniendo, y le asignamos un alias (c). ON e.id_equipo = c.id_equipo: Aqu\u00ed especificamos la condici\u00f3n para la uni\u00f3n. Estamos diciendo que queremos unir las tablas donde el id_equipo de la tabla Equipos coincida con el id_equipo de la tabla Camisetas. Esto asegura que estamos combinando las camisetas con el equipo correcto. GROUP BY e.nombre: GROUP BY: Esta cl\u00e1usula se utiliza para agrupar los resultados de acuerdo a una o m\u00e1s columnas. En este caso, estamos agrupando por el nombre del equipo. e.nombre: Estamos indicando que queremos agrupar los resultados seg\u00fan el nombre del equipo. Esto es esencial porque estamos utilizando una funci\u00f3n de agregaci\u00f3n (SUM), y necesitamos que el motor de la base de datos sepa c\u00f3mo agrupar los datos para calcular el total de stock para cada equipo. Clientes con m\u00faltiples pedidos Encuentra los nombres de los clientes que han realizado m\u00e1s de un pedido. SQL> SELECT c.nombre 2 FROM Clientes c 3 JOIN Pedidos p ON c.id_cliente = p.id_cliente 4 GROUP BY c.id_cliente, c.nombre 5 HAVING COUNT(p.id_pedido) > 1; NOMBRE -------------------------------------------------- Ana G??mez SELECT c.nombre: SELECT: Indica que estamos seleccionando datos de la base de datos. c.nombre: Selecciona el nombre de los clientes. FROM Clientes c: FROM: Indica la tabla desde la cual queremos extraer datos. Clientes c: Especifica que estamos trabajando con la tabla Clientes, utilizando el alias c. JOIN Pedidos p ON c.id_cliente = p.id_cliente: JOIN: Une dos tablas bas\u00e1ndose en una relaci\u00f3n entre ellas. Pedidos p: Indica que estamos uniendo la tabla Pedidos, utilizando el alias p. ON c.id_cliente = p.id_cliente: Establece la condici\u00f3n de uni\u00f3n, donde id_cliente en Clientes coincide con id_cliente en Pedidos. GROUP BY c.id_cliente, c.nombre: GROUP BY: Agrupa los resultados por las columnas especificadas. c.id_cliente, c.nombre: Agrupa los resultados por el id_cliente y el nombre del cliente, lo que permite contar los pedidos por cliente. HAVING COUNT(p.id_pedido) > 1: HAVING: Filtra los grupos resultantes que cumplen con la condici\u00f3n especificada. COUNT(p.id_pedido) > 1: Cuenta el n\u00famero de pedidos por cliente y filtra para incluir solo aquellos clientes que han realizado m\u00e1s de un pedido. Camisetas m\u00e1s caras Escribe una consulta para obtener los detalles de las camisetas que tienen un precio superior a 75.00. SQL> SELECT c.id_camiseta, e.nombre AS nombre_equipo, c.talla, c.precio, c.stock 2 FROM Camisetas c 3 JOIN Equipos e ON c.id_equipo = e.id_equipo 4 WHERE c.precio > 75.00; ID_CAMISETA NOMBRE_EQUIPO TALLA PRECIO STOCK ----------- -------------------------------------------------- ---------- ---------- ---------- 4 Bayern Munich XL 80 50 SELECT c.id_camiseta, e.nombre AS nombre_equipo, c.talla, c.precio, c.stock: Selecciona las columnas que deseas mostrar: el id_camiseta, el nombre del equipo (con alias nombre_equipo), la talla, el precio y el stock. FROM Camisetas c: Indica que estamos extrayendo datos de la tabla Camisetas, utilizando el alias c. JOIN Equipos e ON c.id_equipo = e.id_equipo: Une la tabla Camisetas con la tabla Equipos en funci\u00f3n de id_equipo, lo que permite acceder al nombre del equipo. WHERE c.precio > 75.00: Filtra los resultados para incluir solo las camisetas cuyo precio es superior a 75.00. Pedidos recientes Muestra todos los pedidos realizados en la \u00faltima semana. SQL> SELECT p.id_pedido, p.fecha, c.nombre 2 FROM Pedidos p 3 JOIN Clientes c ON p.id_cliente = c.id_cliente 4 WHERE fecha >= SYSDATE - 7; ID_PEDIDO FECHA NOMBRE ---------- -------- -------------------------------------------------- 1 18/09/24 Juan P??rez 2 18/09/24 Ana G??mez 3 18/09/24 Ana G??mez 4 18/09/24 Ana G??mez 5 18/09/24 Luis Mart??nez SELECT p.id_pedido, p.fecha, c.nombre: SELECT: Indica que estamos seleccionando datos de la base de datos. p.id_pedido: Selecciona el id_pedido de la tabla Pedidos, usando el alias p. p.fecha: Selecciona la columna fecha de la tabla Pedidos, que muestra cu\u00e1ndo se realiz\u00f3 cada pedido. c.nombre: Selecciona el nombre del cliente de la tabla Clientes, usando el alias c. FROM Pedidos p: FROM: Indica de qu\u00e9 tabla queremos extraer datos. Pedidos p: Especifica que estamos trabajando con la tabla Pedidos, utilizando el alias p para referirnos a ella de forma m\u00e1s corta. JOIN Clientes c ON p.id_cliente = c.id_cliente: JOIN: Une dos tablas bas\u00e1ndose en una relaci\u00f3n entre ellas. Clientes c: Indica que estamos uniendo la tabla Clientes, utilizando el alias c. ON p.id_cliente = c.id_cliente: Establece la condici\u00f3n de uni\u00f3n. Aqu\u00ed estamos diciendo que queremos unir las filas de Pedidos y Clientes donde el id_cliente de la tabla Pedidos coincide con el id_cliente de la tabla Clientes. Esto permite obtener el nombre del cliente correspondiente a cada pedido. WHERE fecha >= SYSDATE - 7: WHERE: Filtra los resultados de la consulta seg\u00fan la condici\u00f3n especificada. fecha >= SYSDATE - 7: Esta condici\u00f3n selecciona los pedidos cuya fecha es mayor o igual a la fecha actual menos 7 d\u00edas. En otras palabras, est\u00e1 buscando pedidos realizados en la \u00faltima semana. Camisetas por talla Cuenta cu\u00e1ntas camisetas hay disponibles para cada talla. SQL> SELECT e.nombre, c.id_camiseta, c.talla, c.stock 2 FROM Camisetas c 3 JOIN Equipos e ON c.id_equipo = e.id_equipo 4 WHERE stock > 0; NOMBRE ID_CAMISETA TALLA STOCK -------------------------------------------------- ----------- ---------- ---------- FC Barcelona 1 M 100 Real Madrid 2 L 150 Manchester United 3 S 200 Bayern Munich 4 XL 50 SELECT e.nombre, c.id_camiseta, c.talla, c.stock: e.nombre: Selecciona el nombre del equipo. c.id_camiseta: Selecciona el identificador de la camiseta. c.talla: Selecciona la talla de la camiseta. c.stock: Selecciona la cantidad de stock disponible para cada camiseta. FROM Camisetas c: Indica que estamos trabajando con la tabla Camisetas, utilizando el alias c. JOIN Equipos e ON c.id_equipo = e.id_equipo: Une la tabla Camisetas con la tabla Equipos donde el id_equipo en Camisetas coincide con el id_equipo en Equipos. Esto permite acceder al nombre del equipo asociado con cada camiseta. WHERE c.stock > 0: Filtra los resultados para incluir solo las camisetas que tienen stock disponible, es decir, aquellas cuyo valor de stock es mayor que 0. Jugadores por equipo Genera una lista que muestre los nombres de los jugadores junto con el nombre de su equipo. SQL> SELECT j.nombre AS nombre_jugador, e.nombre AS nombre_equipo 2 FROM Jugadores j 3 JOIN Equipos e ON j.id_equipo = e.id_equipo; NOMBRE_JUGADOR NOMBRE_EQUIPO --------------- --------------- Lionel Messi FC Barcelona Cristiano Ronaldo Real Madrid Marcus Rashford Manchester United Robert Lewandowski Bayern Munich SELECT j.nombre AS nombre_jugador, e.nombre AS nombre_equipo: j.nombre AS nombre_jugador: Selecciona el nombre de cada jugador y le asigna el alias nombre_jugador. e.nombre AS nombre_equipo: Selecciona el nombre del equipo correspondiente y le asigna el alias nombre_equipo. FROM Jugadores j: FROM: Indica de qu\u00e9 tabla queremos extraer datos. Jugadores j: Especifica que estamos trabajando con la tabla Jugadores, utilizando el alias j. JOIN Equipos e ON j.id_equipo = e.id_equipo: JOIN: Une dos tablas en funci\u00f3n de una relaci\u00f3n entre ellas. Equipos e: Indica que estamos uniendo la tabla Equipos, utilizando el alias e. ON j.id_equipo = e.id_equipo: Establece la condici\u00f3n de uni\u00f3n, donde el id_equipo en Jugadores coincide con el id_equipo en Equipos. Esto permite asociar cada jugador con su equipo correspondiente. HAZ CLIC PARA VER LA SOLUCI\u00d3N Clientes sin pedidos Encuentra los nombres de los clientes que no han realizado ning\u00fan pedido. SQL> SELECT c.nombre FROM Clientes c LEFT JOIN Pedidos p ON c.id_cliente = p.id_cliente WHERE p.id_pedido IS NULL; NOMBRE -------------------------------------------------- Mar??a L??pez SELECT c.nombre: Selecciona el nombre de los clientes. FROM Clientes c: Indica que estamos trabajando con la tabla Clientes, usando el alias c. LEFT JOIN Pedidos p ON c.id_cliente = p.id_cliente: Realiza una uni\u00f3n a la izquierda (LEFT JOIN) entre Clientes y Pedidos. Esto incluye todos los registros de Clientes y los registros coincidentes de Pedidos. Si no hay coincidencias, las columnas de Pedidos ser\u00e1n NULL. WHERE p.id_pedido IS NULL: Filtra los resultados para incluir solo aquellos clientes que no tienen ning\u00fan pedido asociado. Esto se determina porque el id_pedido en la tabla Pedidos ser\u00e1 NULL si no hay coincidencias. Detalles de pedidos de un cliente espec\u00edfico Muestra el nombre del cliente junto con todos los detalles de los pedidos realizados por un cliente con un ID espec\u00edfico. SQL> SELECT c.nombre, p.* 2 FROM Clientes c 3 JOIN Pedidos p ON c.id_cliente = p.id_cliente 4 WHERE c.id_cliente = 1; NOMBRE ID_PEDIDO ID_CLIENTE FECHA -------------------------------------------------- ---------- ---------- -------- Juan P??rez 1 1 18/09/24 SELECT c.nombre, p.*: c.nombre: Selecciona el nombre del cliente. p.*: Selecciona todas las columnas de la tabla Pedidos. FROM Clientes c: Indica que estamos trabajando con la tabla Clientes, utilizando el alias c. JOIN Pedidos p ON c.id_cliente = p.id_cliente: Une la tabla Clientes con la tabla Pedidos donde el id_cliente en Clientes coincide con el id_cliente en Pedidos. WHERE c.id_cliente = 1: Filtra los resultados para incluir solo los pedidos del cliente con el ID espec\u00edfico. Cambia el n\u00famero 1 por el ID del cliente que deseas consultar. Promedio de precios de camisetas Calcula el precio promedio de las camisetas por equipo. SQL> SELECT e.nombre AS nombre_equipo, AVG(c.precio) AS precio_promedio 2 FROM Camisetas c 3 JOIN Equipos e ON c.id_equipo = e.id_equipo 4 GROUP BY e.nombre; NOMBRE_EQUIPO PRECIO_PROMEDIO -------------------------------------------------- --------------- Real Madrid 75 Bayern Munich 80 FC Barcelona 70 Manchester United 65 SELECT e.nombre AS nombre_equipo, AVG(c.precio) AS precio_promedio: e.nombre AS nombre_equipo: Selecciona el nombre del equipo y le asigna el alias nombre_equipo. AVG(c.precio) AS precio_promedio: Calcula el precio promedio de las camisetas y le asigna el alias precio_promedio. FROM Camisetas c: Indica que estamos trabajando con la tabla Camisetas, usando el alias c. JOIN Equipos e ON c.id_equipo = e.id_equipo: Une la tabla Camisetas con la tabla Equipos donde el id_equipo en Camisetas coincide con el id_equipo en Equipos. Esto permite acceder al nombre del equipo asociado con cada camiseta. GROUP BY e.nombre: Agrupa los resultados por el nombre del equipo. Esto es necesario cuando se utilizan funciones de agregaci\u00f3n, para que se calcule el precio promedio por cada equipo.** Ejercicios Avanzados Cantidad total de camisetas por cliente: Crea una consulta que muestre cu\u00e1ntas camisetas ha comprado cada cliente en total. SQL> SELECT c.nombre AS cliente, SUM(dp.cantidad) AS total_camisetas 2 FROM Clientes c 3 JOIN Pedidos p ON c.id_cliente = p.id_cliente 4 JOIN Detalles_Pedidos dp ON p.id_pedido = dp.id_pedido 5 GROUP BY c.nombre 6 ORDER BY total_camisetas DESC; CLIENTE TOTAL_CAMISETAS -------------------------------------------------- --------------- Fernando Torres 3 Carlos Ram??rez 3 Juan P??rez 2 Laura L??pez 2 Jos?? Mart??nez 2 Claudia Ruiz 1 Sof??a S??nchez 1 Ana G??mez 1 Luis Hern??ndez 1 Mar??a Rodr??guez 1 Paso 1: SELECT SELECT c.nombre AS cliente, SUM(dp.cantidad) AS total_camisetas c.nombre AS cliente: En este paso seleccionamos el nombre del cliente de la tabla Clientes (alias c). El alias AS cliente simplemente renombra la columna de salida a \"cliente\" para que el resultado sea m\u00e1s claro. SUM(dp.cantidad) AS total_camisetas: Calculamos la suma de la cantidad de camisetas compradas por cada cliente usando la columna cantidad de la tabla Detalles_Pedidos (alias dp). El alias AS total_camisetas renombra esta suma a \"total_camisetas\" en el resultado. Paso 2: FROM FROM Clientes c Aqu\u00ed definimos que la tabla principal ser\u00e1 Clientes con el alias c. A partir de esta tabla comenzaremos a hacer las uniones con otras tablas. Paso 3: JOIN entre Clientes y Pedidos JOIN Pedidos p ON c.id_cliente = p.id_cliente JOIN: Utilizamos un INNER JOIN (de manera impl\u00edcita al usar JOIN) para unir la tabla Pedidos (alias p) con la tabla Clientes. ON c.id_cliente = p.id_cliente: Se indica la relaci\u00f3n entre estas dos tablas, es decir, cada cliente puede tener uno o m\u00e1s pedidos, y un pedido est\u00e1 asociado a un solo cliente a trav\u00e9s de la clave for\u00e1nea id_cliente. Paso 4: JOIN entre Pedidos y Detalles_Pedidos JOIN Detalles_Pedidos dp ON p.id_pedido = dp.id_pedido Nuevamente utilizamos un INNER JOIN, pero ahora unimos la tabla Pedidos con Detalles_Pedidos. ON p.id_pedido = dp.id_pedido: Se especifica que la relaci\u00f3n es a trav\u00e9s de la columna id_pedido. Esto nos permite obtener la informaci\u00f3n de cada detalle del pedido, como la cantidad de camisetas compradas en cada uno. Paso 5: GROUP BY GROUP BY c.nombre GROUP BY: Agrupa los resultados por el nombre del cliente (c.nombre). Esto asegura que la funci\u00f3n de agregaci\u00f3n (en este caso, SUM) se aplique por cliente, no por cada fila individual de la tabla de detalles. Paso 6: ORDER BY ORDER BY total_camisetas DESC; ORDER BY: Finalmente, ordenamos los resultados seg\u00fan el total de camisetas compradas (total_camisetas) en orden descendente (DESC), mostrando primero los clientes que han comprado m\u00e1s camisetas. Jugadores destacados: Selecciona los jugadores que juegan en la posici\u00f3n \"Delantero\" y que pertenecen al equipo \"FC Barcelona\". SQL> SELECT j.nombre AS Nombre_Jugador FROM SELECT j.nombre AS Nombre_Jugador 2 FROM Jugadores j 3 JOIN Equipos e ON j.id_equipo = e.id_equipo 4 WHERE j.posicion = 'Delantero' AND e.nombre = 'FC Barcelona'; NOMBRE_JUGADOR -------------------------------------------------- Lionel Messi Camisetas vendidas: Muestra una lista con el nombre de las camisetas y la cantidad vendida para cada una. SQL> SELECT e.nombre AS Nombre_Camiseta, c.talla, SUM(dp.cantidad) AS cantidad_vendida 2 FROM Equipos e 3 JOIN Camisetas c ON e.id_equipo = c.id_equipo 4 JOIN Detalles_Pedidos dp ON c.id_camiseta = dp.id_camiseta 5 GROUP BY e.nombre, c.talla 6 ORDER BY cantidad_vendida DESC; NOMBRE_CAMISETA TALLA CANTIDAD_VENDIDA -------------------------------------------------- ---------- ---------------- Chelsea FC S 3 FC Barcelona M 3 Real Madrid L 2 Manchester United S 2 Juventus M 2 Bayern M??nich L 1 Paris Saint-Germain M 1 Liverpool FC M 1 Atl??tico de Madrid M 1 AC Milan L 1 Clientes que compraron camisetas de un equipo espec\u00edfico: Encuentra los nombres de los clientes que han comprado camisetas de un equipo cuyo nombre es \"Bayern Munich\". SQL> SELECT DISTINCT c.nombre AS cliente FROM SELECT DISTINCT c.nombre AS cliente 2 FROM Clientes c 3 JOIN Pedidos p ON c.id_cliente = p.id_cliente 4 JOIN Detalles_Pedidos dp ON p.id_pedido = dp.id_pedido 5 JOIN Camisetas ca ON dp.id_camiseta = ca.id_camiseta 6 JOIN Equipos e ON ca.id_equipo = e.id_equipo 7 WHERE e.nombre = 'Bayern M\u00fanich'; CLIENTE -------------------------------------------------- Claudia Ruiz Paso 1: SELECT SELECT DISTINCT c.nombre AS cliente SELECT: Especifica las columnas que queremos en el resultado final. c.nombre AS cliente: Seleccionamos el nombre del cliente de la tabla Clientes (con alias c). El alias AS cliente renombra esta columna en el resultado a \"cliente\" para mayor claridad. DISTINCT: Asegura que los nombres de los clientes en el resultado sean \u00fanicos. Si un cliente ha hecho varias compras de camisetas del mismo equipo, solo aparecer\u00e1 una vez en el resultado. Paso 2: FROM FROM Clientes c FROM: Indica la tabla principal desde la cual comenzaremos la consulta. En este caso, es Clientes con el alias c. Paso 3: JOIN entre Clientes y Pedidos JOIN Pedidos p ON c.id_cliente = p.id_cliente JOIN: Realizamos un INNER JOIN entre Clientes (alias c) y Pedidos (alias p). Esto une las dos tablas bas\u00e1ndose en la relaci\u00f3n entre ellas. ON c.id_cliente = p.id_cliente: Especifica la condici\u00f3n de uni\u00f3n: la columna id_cliente en Clientes debe coincidir con id_cliente en Pedidos. Esto asocia cada cliente con sus pedidos. Paso 4: JOIN entre Pedidos y Detales Pedidos JOIN Detalles_Pedidos dp ON p.id_pedido = dp.id_pedido JOIN: Unimos la tabla Pedidos (alias p) con la tabla Detalles_Pedidos (alias dp). ON p.id_pedido = dp.id_pedido: Establece la condici\u00f3n de uni\u00f3n entre las dos tablas, usando la columna id_pedido. Esto nos permite obtener detalles espec\u00edficos de cada pedido. Paso 5: JOIN entre Detalles Pedidos y camisetas JOIN Camisetas ca ON dp.id_camiseta = ca.id_camiseta JOIN: Realizamos un INNER JOIN entre Detalles_Pedidos (alias dp) y Camisetas (alias ca). ON dp.id_camiseta = ca.id_camiseta: Relaciona las dos tablas usando la columna id_camiseta. Esto nos proporciona informaci\u00f3n sobre las camisetas compradas en cada detalle del pedido. Paso 6: JOIN Camisetas y equipos JOIN Equipos e ON ca.id_equipo = e.id_equipo JOIN: Unimos la tabla Camisetas (alias ca) con la tabla Equipos (alias e). ON ca.id_equipo = e.id_equipo: Especifica que la uni\u00f3n se realiza a trav\u00e9s de la columna id_equipo. Esto nos da acceso a la informaci\u00f3n sobre el equipo al que pertenece cada camiseta. Paso 7: WHERE WHERE e.nombre = 'Bayern M\u00fanich' WHERE: Filtra los resultados para incluir solo aquellos en los que el nombre del equipo (e.nombre) sea 'Bayern M\u00fanich'. Esto asegura que solo se muestren los clientes que han comprado camisetas de este equipo espec\u00edfico.","title":"Consultas"},{"location":"bbdd/sgbd-rel/oracle/consultas/#ejercicios-de-consultas-sql","text":"","title":"Ejercicios de Consultas SQL"},{"location":"bbdd/sgbd-rel/oracle/consultas/#esquema-base-de-datos","text":"Dada la siguiente base de datos realizaremos una serie de consultas.:","title":"Esquema Base de datos"},{"location":"bbdd/sgbd-rel/oracle/consultas/#ejercicios-basicos","text":"","title":"Ejercicios B\u00e1sicos"},{"location":"bbdd/sgbd-rel/oracle/consultas/#obtener-todos-los-equipos","text":"Escribe una consulta para listar todos los nombres de los equipos en la tabla Equipos. SQL> SELECT nombre 2 FROM equipos; NOMBRE -------------------------------------------------- FC Barcelona Real Madrid Manchester United Bayern Munich SELECT nombre: SELECT: Indica que estamos interesados en obtener datos de la base de datos. nombre: Especifica la columna que deseamos seleccionar. En este caso, se refiere a la columna que contiene los nombres de los equipos. FROM equipos: FROM: Especifica de qu\u00e9 tabla queremos extraer la informaci\u00f3n. equipos: Indica que la consulta debe buscar los datos en la tabla llamada equipos.","title":"Obtener todos los equipos"},{"location":"bbdd/sgbd-rel/oracle/consultas/#contar-camisetas-en-stock","text":"Realiza una consulta que cuente cu\u00e1ntas camisetas hay en stock para cada equipo. SQL> SELECT e.nombre AS equipo, SUM(c.stock) AS total_camisetas 2 FROM Equipos e 3 JOIN Camisetas c ON e.id_equipo = c.id_equipo 4 GROUP BY e.nombre; EQUIPO TOTAL_CAMISETAS -------------------------------------------------- --------------- Real Madrid 150 Bayern Munich 50 FC Barcelona 100 Manchester United 200 SELECT e.nombre AS equipo, SUM(c.stock) AS total_camisetas: SELECT: Esta cl\u00e1usula indica qu\u00e9 columnas deseas ver en el resultado de la consulta. e.nombre AS equipo: Aqu\u00ed estamos seleccionando el nombre del equipo (de la tabla Equipos) y le estamos dando un alias (equipo) para que sea m\u00e1s f\u00e1cil de entender en los resultados. SUM(c.stock) AS total_camisetas: Estamos usando la funci\u00f3n de agregaci\u00f3n SUM para sumar el stock de camisetas (de la tabla Camisetas). El resultado de esta suma se denomina total_camisetas. FROM Equipos e: FROM: Indica de qu\u00e9 tablas se extraer\u00e1n los datos. Equipos e: Aqu\u00ed estamos seleccionando la tabla Equipos y le estamos asignando un alias (e). Los alias son \u00fatiles para simplificar la referencia a las tablas en la consulta. JOIN Camisetas c ON e.id_equipo = c.id_equipo: JOIN: Se utiliza para combinar filas de dos o m\u00e1s tablas basadas en una relaci\u00f3n entre ellas. Camisetas c: Esta es la segunda tabla que estamos uniendo, y le asignamos un alias (c). ON e.id_equipo = c.id_equipo: Aqu\u00ed especificamos la condici\u00f3n para la uni\u00f3n. Estamos diciendo que queremos unir las tablas donde el id_equipo de la tabla Equipos coincida con el id_equipo de la tabla Camisetas. Esto asegura que estamos combinando las camisetas con el equipo correcto. GROUP BY e.nombre: GROUP BY: Esta cl\u00e1usula se utiliza para agrupar los resultados de acuerdo a una o m\u00e1s columnas. En este caso, estamos agrupando por el nombre del equipo. e.nombre: Estamos indicando que queremos agrupar los resultados seg\u00fan el nombre del equipo. Esto es esencial porque estamos utilizando una funci\u00f3n de agregaci\u00f3n (SUM), y necesitamos que el motor de la base de datos sepa c\u00f3mo agrupar los datos para calcular el total de stock para cada equipo.","title":"Contar camisetas en stock"},{"location":"bbdd/sgbd-rel/oracle/consultas/#clientes-con-multiples-pedidos","text":"Encuentra los nombres de los clientes que han realizado m\u00e1s de un pedido. SQL> SELECT c.nombre 2 FROM Clientes c 3 JOIN Pedidos p ON c.id_cliente = p.id_cliente 4 GROUP BY c.id_cliente, c.nombre 5 HAVING COUNT(p.id_pedido) > 1; NOMBRE -------------------------------------------------- Ana G??mez SELECT c.nombre: SELECT: Indica que estamos seleccionando datos de la base de datos. c.nombre: Selecciona el nombre de los clientes. FROM Clientes c: FROM: Indica la tabla desde la cual queremos extraer datos. Clientes c: Especifica que estamos trabajando con la tabla Clientes, utilizando el alias c. JOIN Pedidos p ON c.id_cliente = p.id_cliente: JOIN: Une dos tablas bas\u00e1ndose en una relaci\u00f3n entre ellas. Pedidos p: Indica que estamos uniendo la tabla Pedidos, utilizando el alias p. ON c.id_cliente = p.id_cliente: Establece la condici\u00f3n de uni\u00f3n, donde id_cliente en Clientes coincide con id_cliente en Pedidos. GROUP BY c.id_cliente, c.nombre: GROUP BY: Agrupa los resultados por las columnas especificadas. c.id_cliente, c.nombre: Agrupa los resultados por el id_cliente y el nombre del cliente, lo que permite contar los pedidos por cliente. HAVING COUNT(p.id_pedido) > 1: HAVING: Filtra los grupos resultantes que cumplen con la condici\u00f3n especificada. COUNT(p.id_pedido) > 1: Cuenta el n\u00famero de pedidos por cliente y filtra para incluir solo aquellos clientes que han realizado m\u00e1s de un pedido.","title":"Clientes con m\u00faltiples pedidos"},{"location":"bbdd/sgbd-rel/oracle/consultas/#camisetas-mas-caras","text":"Escribe una consulta para obtener los detalles de las camisetas que tienen un precio superior a 75.00. SQL> SELECT c.id_camiseta, e.nombre AS nombre_equipo, c.talla, c.precio, c.stock 2 FROM Camisetas c 3 JOIN Equipos e ON c.id_equipo = e.id_equipo 4 WHERE c.precio > 75.00; ID_CAMISETA NOMBRE_EQUIPO TALLA PRECIO STOCK ----------- -------------------------------------------------- ---------- ---------- ---------- 4 Bayern Munich XL 80 50 SELECT c.id_camiseta, e.nombre AS nombre_equipo, c.talla, c.precio, c.stock: Selecciona las columnas que deseas mostrar: el id_camiseta, el nombre del equipo (con alias nombre_equipo), la talla, el precio y el stock. FROM Camisetas c: Indica que estamos extrayendo datos de la tabla Camisetas, utilizando el alias c. JOIN Equipos e ON c.id_equipo = e.id_equipo: Une la tabla Camisetas con la tabla Equipos en funci\u00f3n de id_equipo, lo que permite acceder al nombre del equipo. WHERE c.precio > 75.00: Filtra los resultados para incluir solo las camisetas cuyo precio es superior a 75.00.","title":"Camisetas m\u00e1s caras"},{"location":"bbdd/sgbd-rel/oracle/consultas/#pedidos-recientes","text":"Muestra todos los pedidos realizados en la \u00faltima semana. SQL> SELECT p.id_pedido, p.fecha, c.nombre 2 FROM Pedidos p 3 JOIN Clientes c ON p.id_cliente = c.id_cliente 4 WHERE fecha >= SYSDATE - 7; ID_PEDIDO FECHA NOMBRE ---------- -------- -------------------------------------------------- 1 18/09/24 Juan P??rez 2 18/09/24 Ana G??mez 3 18/09/24 Ana G??mez 4 18/09/24 Ana G??mez 5 18/09/24 Luis Mart??nez SELECT p.id_pedido, p.fecha, c.nombre: SELECT: Indica que estamos seleccionando datos de la base de datos. p.id_pedido: Selecciona el id_pedido de la tabla Pedidos, usando el alias p. p.fecha: Selecciona la columna fecha de la tabla Pedidos, que muestra cu\u00e1ndo se realiz\u00f3 cada pedido. c.nombre: Selecciona el nombre del cliente de la tabla Clientes, usando el alias c. FROM Pedidos p: FROM: Indica de qu\u00e9 tabla queremos extraer datos. Pedidos p: Especifica que estamos trabajando con la tabla Pedidos, utilizando el alias p para referirnos a ella de forma m\u00e1s corta. JOIN Clientes c ON p.id_cliente = c.id_cliente: JOIN: Une dos tablas bas\u00e1ndose en una relaci\u00f3n entre ellas. Clientes c: Indica que estamos uniendo la tabla Clientes, utilizando el alias c. ON p.id_cliente = c.id_cliente: Establece la condici\u00f3n de uni\u00f3n. Aqu\u00ed estamos diciendo que queremos unir las filas de Pedidos y Clientes donde el id_cliente de la tabla Pedidos coincide con el id_cliente de la tabla Clientes. Esto permite obtener el nombre del cliente correspondiente a cada pedido. WHERE fecha >= SYSDATE - 7: WHERE: Filtra los resultados de la consulta seg\u00fan la condici\u00f3n especificada. fecha >= SYSDATE - 7: Esta condici\u00f3n selecciona los pedidos cuya fecha es mayor o igual a la fecha actual menos 7 d\u00edas. En otras palabras, est\u00e1 buscando pedidos realizados en la \u00faltima semana.","title":"Pedidos recientes"},{"location":"bbdd/sgbd-rel/oracle/consultas/#camisetas-por-talla","text":"Cuenta cu\u00e1ntas camisetas hay disponibles para cada talla. SQL> SELECT e.nombre, c.id_camiseta, c.talla, c.stock 2 FROM Camisetas c 3 JOIN Equipos e ON c.id_equipo = e.id_equipo 4 WHERE stock > 0; NOMBRE ID_CAMISETA TALLA STOCK -------------------------------------------------- ----------- ---------- ---------- FC Barcelona 1 M 100 Real Madrid 2 L 150 Manchester United 3 S 200 Bayern Munich 4 XL 50 SELECT e.nombre, c.id_camiseta, c.talla, c.stock: e.nombre: Selecciona el nombre del equipo. c.id_camiseta: Selecciona el identificador de la camiseta. c.talla: Selecciona la talla de la camiseta. c.stock: Selecciona la cantidad de stock disponible para cada camiseta. FROM Camisetas c: Indica que estamos trabajando con la tabla Camisetas, utilizando el alias c. JOIN Equipos e ON c.id_equipo = e.id_equipo: Une la tabla Camisetas con la tabla Equipos donde el id_equipo en Camisetas coincide con el id_equipo en Equipos. Esto permite acceder al nombre del equipo asociado con cada camiseta. WHERE c.stock > 0: Filtra los resultados para incluir solo las camisetas que tienen stock disponible, es decir, aquellas cuyo valor de stock es mayor que 0.","title":"Camisetas por talla"},{"location":"bbdd/sgbd-rel/oracle/consultas/#jugadores-por-equipo","text":"Genera una lista que muestre los nombres de los jugadores junto con el nombre de su equipo. SQL> SELECT j.nombre AS nombre_jugador, e.nombre AS nombre_equipo 2 FROM Jugadores j 3 JOIN Equipos e ON j.id_equipo = e.id_equipo; NOMBRE_JUGADOR NOMBRE_EQUIPO --------------- --------------- Lionel Messi FC Barcelona Cristiano Ronaldo Real Madrid Marcus Rashford Manchester United Robert Lewandowski Bayern Munich SELECT j.nombre AS nombre_jugador, e.nombre AS nombre_equipo: j.nombre AS nombre_jugador: Selecciona el nombre de cada jugador y le asigna el alias nombre_jugador. e.nombre AS nombre_equipo: Selecciona el nombre del equipo correspondiente y le asigna el alias nombre_equipo. FROM Jugadores j: FROM: Indica de qu\u00e9 tabla queremos extraer datos. Jugadores j: Especifica que estamos trabajando con la tabla Jugadores, utilizando el alias j. JOIN Equipos e ON j.id_equipo = e.id_equipo: JOIN: Une dos tablas en funci\u00f3n de una relaci\u00f3n entre ellas. Equipos e: Indica que estamos uniendo la tabla Equipos, utilizando el alias e. ON j.id_equipo = e.id_equipo: Establece la condici\u00f3n de uni\u00f3n, donde el id_equipo en Jugadores coincide con el id_equipo en Equipos. Esto permite asociar cada jugador con su equipo correspondiente. HAZ CLIC PARA VER LA SOLUCI\u00d3N","title":"Jugadores por equipo"},{"location":"bbdd/sgbd-rel/oracle/consultas/#clientes-sin-pedidos","text":"Encuentra los nombres de los clientes que no han realizado ning\u00fan pedido. SQL> SELECT c.nombre FROM Clientes c LEFT JOIN Pedidos p ON c.id_cliente = p.id_cliente WHERE p.id_pedido IS NULL; NOMBRE -------------------------------------------------- Mar??a L??pez SELECT c.nombre: Selecciona el nombre de los clientes. FROM Clientes c: Indica que estamos trabajando con la tabla Clientes, usando el alias c. LEFT JOIN Pedidos p ON c.id_cliente = p.id_cliente: Realiza una uni\u00f3n a la izquierda (LEFT JOIN) entre Clientes y Pedidos. Esto incluye todos los registros de Clientes y los registros coincidentes de Pedidos. Si no hay coincidencias, las columnas de Pedidos ser\u00e1n NULL. WHERE p.id_pedido IS NULL: Filtra los resultados para incluir solo aquellos clientes que no tienen ning\u00fan pedido asociado. Esto se determina porque el id_pedido en la tabla Pedidos ser\u00e1 NULL si no hay coincidencias.","title":"Clientes sin pedidos"},{"location":"bbdd/sgbd-rel/oracle/consultas/#detalles-de-pedidos-de-un-cliente-especifico","text":"Muestra el nombre del cliente junto con todos los detalles de los pedidos realizados por un cliente con un ID espec\u00edfico. SQL> SELECT c.nombre, p.* 2 FROM Clientes c 3 JOIN Pedidos p ON c.id_cliente = p.id_cliente 4 WHERE c.id_cliente = 1; NOMBRE ID_PEDIDO ID_CLIENTE FECHA -------------------------------------------------- ---------- ---------- -------- Juan P??rez 1 1 18/09/24 SELECT c.nombre, p.*: c.nombre: Selecciona el nombre del cliente. p.*: Selecciona todas las columnas de la tabla Pedidos. FROM Clientes c: Indica que estamos trabajando con la tabla Clientes, utilizando el alias c. JOIN Pedidos p ON c.id_cliente = p.id_cliente: Une la tabla Clientes con la tabla Pedidos donde el id_cliente en Clientes coincide con el id_cliente en Pedidos. WHERE c.id_cliente = 1: Filtra los resultados para incluir solo los pedidos del cliente con el ID espec\u00edfico. Cambia el n\u00famero 1 por el ID del cliente que deseas consultar.","title":"Detalles de pedidos de un cliente espec\u00edfico"},{"location":"bbdd/sgbd-rel/oracle/consultas/#promedio-de-precios-de-camisetas","text":"Calcula el precio promedio de las camisetas por equipo. SQL> SELECT e.nombre AS nombre_equipo, AVG(c.precio) AS precio_promedio 2 FROM Camisetas c 3 JOIN Equipos e ON c.id_equipo = e.id_equipo 4 GROUP BY e.nombre; NOMBRE_EQUIPO PRECIO_PROMEDIO -------------------------------------------------- --------------- Real Madrid 75 Bayern Munich 80 FC Barcelona 70 Manchester United 65 SELECT e.nombre AS nombre_equipo, AVG(c.precio) AS precio_promedio: e.nombre AS nombre_equipo: Selecciona el nombre del equipo y le asigna el alias nombre_equipo. AVG(c.precio) AS precio_promedio: Calcula el precio promedio de las camisetas y le asigna el alias precio_promedio. FROM Camisetas c: Indica que estamos trabajando con la tabla Camisetas, usando el alias c. JOIN Equipos e ON c.id_equipo = e.id_equipo: Une la tabla Camisetas con la tabla Equipos donde el id_equipo en Camisetas coincide con el id_equipo en Equipos. Esto permite acceder al nombre del equipo asociado con cada camiseta. GROUP BY e.nombre: Agrupa los resultados por el nombre del equipo. Esto es necesario cuando se utilizan funciones de agregaci\u00f3n, para que se calcule el precio promedio por cada equipo.**","title":"Promedio de precios de camisetas"},{"location":"bbdd/sgbd-rel/oracle/consultas/#ejercicios-avanzados","text":"","title":"Ejercicios Avanzados"},{"location":"bbdd/sgbd-rel/oracle/consultas/#cantidad-total-de-camisetas-por-cliente","text":"Crea una consulta que muestre cu\u00e1ntas camisetas ha comprado cada cliente en total. SQL> SELECT c.nombre AS cliente, SUM(dp.cantidad) AS total_camisetas 2 FROM Clientes c 3 JOIN Pedidos p ON c.id_cliente = p.id_cliente 4 JOIN Detalles_Pedidos dp ON p.id_pedido = dp.id_pedido 5 GROUP BY c.nombre 6 ORDER BY total_camisetas DESC; CLIENTE TOTAL_CAMISETAS -------------------------------------------------- --------------- Fernando Torres 3 Carlos Ram??rez 3 Juan P??rez 2 Laura L??pez 2 Jos?? Mart??nez 2 Claudia Ruiz 1 Sof??a S??nchez 1 Ana G??mez 1 Luis Hern??ndez 1 Mar??a Rodr??guez 1 Paso 1: SELECT SELECT c.nombre AS cliente, SUM(dp.cantidad) AS total_camisetas c.nombre AS cliente: En este paso seleccionamos el nombre del cliente de la tabla Clientes (alias c). El alias AS cliente simplemente renombra la columna de salida a \"cliente\" para que el resultado sea m\u00e1s claro. SUM(dp.cantidad) AS total_camisetas: Calculamos la suma de la cantidad de camisetas compradas por cada cliente usando la columna cantidad de la tabla Detalles_Pedidos (alias dp). El alias AS total_camisetas renombra esta suma a \"total_camisetas\" en el resultado. Paso 2: FROM FROM Clientes c Aqu\u00ed definimos que la tabla principal ser\u00e1 Clientes con el alias c. A partir de esta tabla comenzaremos a hacer las uniones con otras tablas. Paso 3: JOIN entre Clientes y Pedidos JOIN Pedidos p ON c.id_cliente = p.id_cliente JOIN: Utilizamos un INNER JOIN (de manera impl\u00edcita al usar JOIN) para unir la tabla Pedidos (alias p) con la tabla Clientes. ON c.id_cliente = p.id_cliente: Se indica la relaci\u00f3n entre estas dos tablas, es decir, cada cliente puede tener uno o m\u00e1s pedidos, y un pedido est\u00e1 asociado a un solo cliente a trav\u00e9s de la clave for\u00e1nea id_cliente. Paso 4: JOIN entre Pedidos y Detalles_Pedidos JOIN Detalles_Pedidos dp ON p.id_pedido = dp.id_pedido Nuevamente utilizamos un INNER JOIN, pero ahora unimos la tabla Pedidos con Detalles_Pedidos. ON p.id_pedido = dp.id_pedido: Se especifica que la relaci\u00f3n es a trav\u00e9s de la columna id_pedido. Esto nos permite obtener la informaci\u00f3n de cada detalle del pedido, como la cantidad de camisetas compradas en cada uno. Paso 5: GROUP BY GROUP BY c.nombre GROUP BY: Agrupa los resultados por el nombre del cliente (c.nombre). Esto asegura que la funci\u00f3n de agregaci\u00f3n (en este caso, SUM) se aplique por cliente, no por cada fila individual de la tabla de detalles. Paso 6: ORDER BY ORDER BY total_camisetas DESC; ORDER BY: Finalmente, ordenamos los resultados seg\u00fan el total de camisetas compradas (total_camisetas) en orden descendente (DESC), mostrando primero los clientes que han comprado m\u00e1s camisetas.","title":"Cantidad total de camisetas por cliente:"},{"location":"bbdd/sgbd-rel/oracle/consultas/#jugadores-destacados","text":"Selecciona los jugadores que juegan en la posici\u00f3n \"Delantero\" y que pertenecen al equipo \"FC Barcelona\". SQL> SELECT j.nombre AS Nombre_Jugador FROM SELECT j.nombre AS Nombre_Jugador 2 FROM Jugadores j 3 JOIN Equipos e ON j.id_equipo = e.id_equipo 4 WHERE j.posicion = 'Delantero' AND e.nombre = 'FC Barcelona'; NOMBRE_JUGADOR -------------------------------------------------- Lionel Messi","title":"Jugadores destacados:"},{"location":"bbdd/sgbd-rel/oracle/consultas/#camisetas-vendidas","text":"Muestra una lista con el nombre de las camisetas y la cantidad vendida para cada una. SQL> SELECT e.nombre AS Nombre_Camiseta, c.talla, SUM(dp.cantidad) AS cantidad_vendida 2 FROM Equipos e 3 JOIN Camisetas c ON e.id_equipo = c.id_equipo 4 JOIN Detalles_Pedidos dp ON c.id_camiseta = dp.id_camiseta 5 GROUP BY e.nombre, c.talla 6 ORDER BY cantidad_vendida DESC; NOMBRE_CAMISETA TALLA CANTIDAD_VENDIDA -------------------------------------------------- ---------- ---------------- Chelsea FC S 3 FC Barcelona M 3 Real Madrid L 2 Manchester United S 2 Juventus M 2 Bayern M??nich L 1 Paris Saint-Germain M 1 Liverpool FC M 1 Atl??tico de Madrid M 1 AC Milan L 1","title":"Camisetas vendidas:"},{"location":"bbdd/sgbd-rel/oracle/consultas/#clientes-que-compraron-camisetas-de-un-equipo-especifico","text":"Encuentra los nombres de los clientes que han comprado camisetas de un equipo cuyo nombre es \"Bayern Munich\". SQL> SELECT DISTINCT c.nombre AS cliente FROM SELECT DISTINCT c.nombre AS cliente 2 FROM Clientes c 3 JOIN Pedidos p ON c.id_cliente = p.id_cliente 4 JOIN Detalles_Pedidos dp ON p.id_pedido = dp.id_pedido 5 JOIN Camisetas ca ON dp.id_camiseta = ca.id_camiseta 6 JOIN Equipos e ON ca.id_equipo = e.id_equipo 7 WHERE e.nombre = 'Bayern M\u00fanich'; CLIENTE -------------------------------------------------- Claudia Ruiz Paso 1: SELECT SELECT DISTINCT c.nombre AS cliente SELECT: Especifica las columnas que queremos en el resultado final. c.nombre AS cliente: Seleccionamos el nombre del cliente de la tabla Clientes (con alias c). El alias AS cliente renombra esta columna en el resultado a \"cliente\" para mayor claridad. DISTINCT: Asegura que los nombres de los clientes en el resultado sean \u00fanicos. Si un cliente ha hecho varias compras de camisetas del mismo equipo, solo aparecer\u00e1 una vez en el resultado. Paso 2: FROM FROM Clientes c FROM: Indica la tabla principal desde la cual comenzaremos la consulta. En este caso, es Clientes con el alias c. Paso 3: JOIN entre Clientes y Pedidos JOIN Pedidos p ON c.id_cliente = p.id_cliente JOIN: Realizamos un INNER JOIN entre Clientes (alias c) y Pedidos (alias p). Esto une las dos tablas bas\u00e1ndose en la relaci\u00f3n entre ellas. ON c.id_cliente = p.id_cliente: Especifica la condici\u00f3n de uni\u00f3n: la columna id_cliente en Clientes debe coincidir con id_cliente en Pedidos. Esto asocia cada cliente con sus pedidos. Paso 4: JOIN entre Pedidos y Detales Pedidos JOIN Detalles_Pedidos dp ON p.id_pedido = dp.id_pedido JOIN: Unimos la tabla Pedidos (alias p) con la tabla Detalles_Pedidos (alias dp). ON p.id_pedido = dp.id_pedido: Establece la condici\u00f3n de uni\u00f3n entre las dos tablas, usando la columna id_pedido. Esto nos permite obtener detalles espec\u00edficos de cada pedido. Paso 5: JOIN entre Detalles Pedidos y camisetas JOIN Camisetas ca ON dp.id_camiseta = ca.id_camiseta JOIN: Realizamos un INNER JOIN entre Detalles_Pedidos (alias dp) y Camisetas (alias ca). ON dp.id_camiseta = ca.id_camiseta: Relaciona las dos tablas usando la columna id_camiseta. Esto nos proporciona informaci\u00f3n sobre las camisetas compradas en cada detalle del pedido. Paso 6: JOIN Camisetas y equipos JOIN Equipos e ON ca.id_equipo = e.id_equipo JOIN: Unimos la tabla Camisetas (alias ca) con la tabla Equipos (alias e). ON ca.id_equipo = e.id_equipo: Especifica que la uni\u00f3n se realiza a trav\u00e9s de la columna id_equipo. Esto nos da acceso a la informaci\u00f3n sobre el equipo al que pertenece cada camiseta. Paso 7: WHERE WHERE e.nombre = 'Bayern M\u00fanich' WHERE: Filtra los resultados para incluir solo aquellos en los que el nombre del equipo (e.nombre) sea 'Bayern M\u00fanich'. Esto asegura que solo se muestren los clientes que han comprado camisetas de este equipo espec\u00edfico.","title":"Clientes que compraron camisetas de un equipo espec\u00edfico:"},{"location":"bbdd/sgbd-rel/oracle/oracle/","text":"Definici\u00f3n Oracle Database es un sistema gestor de bases de datos relacional (SGBD) desarrollado por Oracle Corporation. Es conocido por su robustez, escalabilidad y amplia gama de caracter\u00edsticas que lo convierten en una opci\u00f3n popular para empresas de todos los tama\u00f1os. Caracter\u00edsticas Principales Modelo Relacional: Oracle utiliza un modelo relacional, lo que significa que los datos se organizan en tablas con filas y columnas. Esto permite una f\u00e1cil estructuraci\u00f3n y recuperaci\u00f3n de datos. Transacciones Seguras: Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad), asegurando que las operaciones sean completas y fiables. Escalabilidad: Oracle puede manejar grandes vol\u00famenes de datos y un alto n\u00famero de usuarios concurrentes, lo que lo hace adecuado para aplicaciones empresariales cr\u00edticas. Alta Disponibilidad: Incluye caracter\u00edsticas como Oracle Real Application Clusters (RAC), que permiten que m\u00faltiples servidores trabajen juntos, asegurando que la base de datos est\u00e9 disponible incluso si uno de los servidores falla. Seguridad Avanzada: Ofrece robustas caracter\u00edsticas de seguridad, incluyendo autenticaci\u00f3n de usuarios, encriptaci\u00f3n de datos y control de acceso basado en roles. Herramientas de Desarrollo: Proporciona herramientas como Oracle SQL Developer y Oracle Application Express (APEX) para facilitar el desarrollo y la gesti\u00f3n de bases de datos. Compatibilidad con NoSQL: A trav\u00e9s de Oracle Database 21c y versiones posteriores, se integra con modelos de datos NoSQL, permitiendo trabajar con documentos JSON y datos de grafos. Soporte para SQL y PL/SQL: Utiliza SQL como lenguaje de consulta est\u00e1ndar y PL/SQL (Procedural Language/SQL) para el desarrollo de aplicaciones, permitiendo la programaci\u00f3n de l\u00f3gica compleja en la base de datos. Casos de Uso Aplicaciones Empresariales: Ideal para aplicaciones cr\u00edticas en sectores como finanzas, salud y telecomunicaciones. Data Warehousing: Adecuado para la consolidaci\u00f3n y an\u00e1lisis de grandes vol\u00famenes de datos. E-commerce: Soporta plataformas de comercio electr\u00f3nico con alta carga de transacciones. Conclusi\u00f3n Oracle Database es una soluci\u00f3n poderosa y vers\u00e1til para la gesti\u00f3n de datos en entornos empresariales. Su capacidad para manejar grandes vol\u00famenes de informaci\u00f3n, junto con caracter\u00edsticas de seguridad y disponibilidad, lo convierte en una opci\u00f3n preferida para organizaciones que requieren un SGBD robusto y confiable.","title":"Oracle"},{"location":"bbdd/sgbd-rel/oracle/oracle/#definicion","text":"Oracle Database es un sistema gestor de bases de datos relacional (SGBD) desarrollado por Oracle Corporation. Es conocido por su robustez, escalabilidad y amplia gama de caracter\u00edsticas que lo convierten en una opci\u00f3n popular para empresas de todos los tama\u00f1os.","title":"Definici\u00f3n"},{"location":"bbdd/sgbd-rel/oracle/oracle/#caracteristicas-principales","text":"Modelo Relacional: Oracle utiliza un modelo relacional, lo que significa que los datos se organizan en tablas con filas y columnas. Esto permite una f\u00e1cil estructuraci\u00f3n y recuperaci\u00f3n de datos. Transacciones Seguras: Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad), asegurando que las operaciones sean completas y fiables. Escalabilidad: Oracle puede manejar grandes vol\u00famenes de datos y un alto n\u00famero de usuarios concurrentes, lo que lo hace adecuado para aplicaciones empresariales cr\u00edticas. Alta Disponibilidad: Incluye caracter\u00edsticas como Oracle Real Application Clusters (RAC), que permiten que m\u00faltiples servidores trabajen juntos, asegurando que la base de datos est\u00e9 disponible incluso si uno de los servidores falla. Seguridad Avanzada: Ofrece robustas caracter\u00edsticas de seguridad, incluyendo autenticaci\u00f3n de usuarios, encriptaci\u00f3n de datos y control de acceso basado en roles. Herramientas de Desarrollo: Proporciona herramientas como Oracle SQL Developer y Oracle Application Express (APEX) para facilitar el desarrollo y la gesti\u00f3n de bases de datos. Compatibilidad con NoSQL: A trav\u00e9s de Oracle Database 21c y versiones posteriores, se integra con modelos de datos NoSQL, permitiendo trabajar con documentos JSON y datos de grafos. Soporte para SQL y PL/SQL: Utiliza SQL como lenguaje de consulta est\u00e1ndar y PL/SQL (Procedural Language/SQL) para el desarrollo de aplicaciones, permitiendo la programaci\u00f3n de l\u00f3gica compleja en la base de datos.","title":"Caracter\u00edsticas Principales"},{"location":"bbdd/sgbd-rel/oracle/oracle/#casos-de-uso","text":"Aplicaciones Empresariales: Ideal para aplicaciones cr\u00edticas en sectores como finanzas, salud y telecomunicaciones. Data Warehousing: Adecuado para la consolidaci\u00f3n y an\u00e1lisis de grandes vol\u00famenes de datos. E-commerce: Soporta plataformas de comercio electr\u00f3nico con alta carga de transacciones.","title":"Casos de Uso"},{"location":"bbdd/sgbd-rel/oracle/oracle/#conclusion","text":"Oracle Database es una soluci\u00f3n poderosa y vers\u00e1til para la gesti\u00f3n de datos en entornos empresariales. Su capacidad para manejar grandes vol\u00famenes de informaci\u00f3n, junto con caracter\u00edsticas de seguridad y disponibilidad, lo convierte en una opci\u00f3n preferida para organizaciones que requieren un SGBD robusto y confiable.","title":"Conclusi\u00f3n"},{"location":"bbdd/sgbd-rel/oracle/plsql/","text":"Definici\u00f3n PL/SQL (Procedural Language/Structured Query Language) es un lenguaje de programaci\u00f3n de prop\u00f3sito espec\u00edfico desarrollado por Oracle para interactuar con su sistema de gesti\u00f3n de bases de datos. Combina caracter\u00edsticas de SQL, que es un lenguaje declarativo utilizado para manipular datos, con la programaci\u00f3n procedural, permitiendo el desarrollo de aplicaciones complejas. Caracter\u00edsticas Principales Integraci\u00f3n con SQL: PL/SQL permite la ejecuci\u00f3n de sentencias SQL dentro de su sintaxis, lo que facilita el acceso y la manipulaci\u00f3n de datos en la base de datos Oracle. Estructuras de Control: Ofrece estructuras de control como condicionales (IF, CASE) y bucles (FOR, WHILE), permitiendo la implementaci\u00f3n de l\u00f3gica de programaci\u00f3n compleja. Manejo de Excepciones: Proporciona un mecanismo robusto para el manejo de errores a trav\u00e9s de bloques de excepciones, lo que permite gestionar situaciones imprevistas de manera controlada. Modularidad: Permite crear procedimientos, funciones y paquetes, facilitando la organizaci\u00f3n del c\u00f3digo y la reutilizaci\u00f3n de funciones. Declaraci\u00f3n de Variables: Soporta la declaraci\u00f3n de variables, constantes y tipos de datos, lo que permite almacenar y manipular datos dentro de los bloques PL/SQL. Ejecuci\u00f3n en el Servidor: PL/SQL se ejecuta en el servidor de base de datos, lo que minimiza la cantidad de datos que deben transferirse entre el cliente y el servidor, mejorando el rendimiento. Componentes de PL/SQL Bloques PL/SQL: Un programa PL/SQL est\u00e1 compuesto por bloques, que pueden ser anidados. Cada bloque tiene tres secciones: Declarativa: Para definir variables y tipos de datos. Ejecutiva: Donde se ejecutan las sentencias SQL y la l\u00f3gica del programa. Excepcional: Para manejar errores que puedan surgir durante la ejecuci\u00f3n. DECLARE v_salario NUMBER; BEGIN SELECT salario INTO v_salario FROM empleados WHERE id = 1; DBMS_OUTPUT.PUT_LINE('Salario: ' || v_salario); EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('Empleado no encontrado.'); END; Procedimientos y Funciones Procedimientos: Bloques de c\u00f3digo que realizan una tarea espec\u00edfica y no devuelven un valor. Funciones: Similar a los procedimientos, pero devuelven un valor. Paquetes Agrupan procedimientos y funciones relacionados, junto con variables y tipos de datos, facilitando la organizaci\u00f3n y el manejo de c\u00f3digo. Ventajas de PL/SQL Eficiencia: Al ejecutarse en el servidor, reduce el tr\u00e1fico de red y mejora el rendimiento. Seguridad: Permite controlar el acceso a los datos mediante la implementaci\u00f3n de l\u00f3gica de negocio en el servidor. Mantenimiento: Facilita el mantenimiento y la reutilizaci\u00f3n del c\u00f3digo a trav\u00e9s de la modularidad y la organizaci\u00f3n en paquetes. Casos de Uso Automatizaci\u00f3n de Tareas: PL/SQL se utiliza para crear scripts que automatizan procesos de gesti\u00f3n de datos. Validaci\u00f3n de Datos: Implementaci\u00f3n de l\u00f3gica de negocio para garantizar la integridad de los datos. Desarrollo de Aplicaciones: Usado en el desarrollo de aplicaciones que requieren acceso a la base de datos, como aplicaciones empresariales. Conclusi\u00f3n PL/SQL es una herramienta poderosa y vers\u00e1til para los desarrolladores que trabajan con bases de datos Oracle. Su capacidad para combinar SQL con la programaci\u00f3n procedural facilita la creaci\u00f3n de aplicaciones complejas y eficientes, optimizando la gesti\u00f3n de datos y mejorando el rendimiento general de las operaciones en la base de datos.","title":"PL/SQL"},{"location":"bbdd/sgbd-rel/oracle/plsql/#definicion","text":"PL/SQL (Procedural Language/Structured Query Language) es un lenguaje de programaci\u00f3n de prop\u00f3sito espec\u00edfico desarrollado por Oracle para interactuar con su sistema de gesti\u00f3n de bases de datos. Combina caracter\u00edsticas de SQL, que es un lenguaje declarativo utilizado para manipular datos, con la programaci\u00f3n procedural, permitiendo el desarrollo de aplicaciones complejas.","title":"Definici\u00f3n"},{"location":"bbdd/sgbd-rel/oracle/plsql/#caracteristicas-principales","text":"Integraci\u00f3n con SQL: PL/SQL permite la ejecuci\u00f3n de sentencias SQL dentro de su sintaxis, lo que facilita el acceso y la manipulaci\u00f3n de datos en la base de datos Oracle. Estructuras de Control: Ofrece estructuras de control como condicionales (IF, CASE) y bucles (FOR, WHILE), permitiendo la implementaci\u00f3n de l\u00f3gica de programaci\u00f3n compleja. Manejo de Excepciones: Proporciona un mecanismo robusto para el manejo de errores a trav\u00e9s de bloques de excepciones, lo que permite gestionar situaciones imprevistas de manera controlada. Modularidad: Permite crear procedimientos, funciones y paquetes, facilitando la organizaci\u00f3n del c\u00f3digo y la reutilizaci\u00f3n de funciones. Declaraci\u00f3n de Variables: Soporta la declaraci\u00f3n de variables, constantes y tipos de datos, lo que permite almacenar y manipular datos dentro de los bloques PL/SQL. Ejecuci\u00f3n en el Servidor: PL/SQL se ejecuta en el servidor de base de datos, lo que minimiza la cantidad de datos que deben transferirse entre el cliente y el servidor, mejorando el rendimiento.","title":"Caracter\u00edsticas Principales"},{"location":"bbdd/sgbd-rel/oracle/plsql/#componentes-de-plsql","text":"","title":"Componentes de PL/SQL"},{"location":"bbdd/sgbd-rel/oracle/plsql/#bloques-plsql","text":"Un programa PL/SQL est\u00e1 compuesto por bloques, que pueden ser anidados. Cada bloque tiene tres secciones: Declarativa: Para definir variables y tipos de datos. Ejecutiva: Donde se ejecutan las sentencias SQL y la l\u00f3gica del programa. Excepcional: Para manejar errores que puedan surgir durante la ejecuci\u00f3n. DECLARE v_salario NUMBER; BEGIN SELECT salario INTO v_salario FROM empleados WHERE id = 1; DBMS_OUTPUT.PUT_LINE('Salario: ' || v_salario); EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('Empleado no encontrado.'); END;","title":"Bloques PL/SQL:"},{"location":"bbdd/sgbd-rel/oracle/plsql/#procedimientos-y-funciones","text":"Procedimientos: Bloques de c\u00f3digo que realizan una tarea espec\u00edfica y no devuelven un valor. Funciones: Similar a los procedimientos, pero devuelven un valor.","title":"Procedimientos y Funciones"},{"location":"bbdd/sgbd-rel/oracle/plsql/#paquetes","text":"Agrupan procedimientos y funciones relacionados, junto con variables y tipos de datos, facilitando la organizaci\u00f3n y el manejo de c\u00f3digo.","title":"Paquetes"},{"location":"bbdd/sgbd-rel/oracle/plsql/#ventajas-de-plsql","text":"Eficiencia: Al ejecutarse en el servidor, reduce el tr\u00e1fico de red y mejora el rendimiento. Seguridad: Permite controlar el acceso a los datos mediante la implementaci\u00f3n de l\u00f3gica de negocio en el servidor. Mantenimiento: Facilita el mantenimiento y la reutilizaci\u00f3n del c\u00f3digo a trav\u00e9s de la modularidad y la organizaci\u00f3n en paquetes.","title":"Ventajas de PL/SQL"},{"location":"bbdd/sgbd-rel/oracle/plsql/#casos-de-uso","text":"Automatizaci\u00f3n de Tareas: PL/SQL se utiliza para crear scripts que automatizan procesos de gesti\u00f3n de datos. Validaci\u00f3n de Datos: Implementaci\u00f3n de l\u00f3gica de negocio para garantizar la integridad de los datos. Desarrollo de Aplicaciones: Usado en el desarrollo de aplicaciones que requieren acceso a la base de datos, como aplicaciones empresariales.","title":"Casos de Uso"},{"location":"bbdd/sgbd-rel/oracle/plsql/#conclusion","text":"PL/SQL es una herramienta poderosa y vers\u00e1til para los desarrolladores que trabajan con bases de datos Oracle. Su capacidad para combinar SQL con la programaci\u00f3n procedural facilita la creaci\u00f3n de aplicaciones complejas y eficientes, optimizando la gesti\u00f3n de datos y mejorando el rendimiento general de las operaciones en la base de datos.","title":"Conclusi\u00f3n"},{"location":"bbdd/sgbd-rel/postgresql/oracle/","text":"Definici\u00f3n Oracle Database es un sistema gestor de bases de datos relacional (SGBD) desarrollado por Oracle Corporation. Es conocido por su robustez, escalabilidad y amplia gama de caracter\u00edsticas que lo convierten en una opci\u00f3n popular para empresas de todos los tama\u00f1os. Caracter\u00edsticas Principales Modelo Relacional: Oracle utiliza un modelo relacional, lo que significa que los datos se organizan en tablas con filas y columnas. Esto permite una f\u00e1cil estructuraci\u00f3n y recuperaci\u00f3n de datos. Transacciones Seguras: Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad), asegurando que las operaciones sean completas y fiables. Escalabilidad: Oracle puede manejar grandes vol\u00famenes de datos y un alto n\u00famero de usuarios concurrentes, lo que lo hace adecuado para aplicaciones empresariales cr\u00edticas. Alta Disponibilidad: Incluye caracter\u00edsticas como Oracle Real Application Clusters (RAC), que permiten que m\u00faltiples servidores trabajen juntos, asegurando que la base de datos est\u00e9 disponible incluso si uno de los servidores falla. Seguridad Avanzada: Ofrece robustas caracter\u00edsticas de seguridad, incluyendo autenticaci\u00f3n de usuarios, encriptaci\u00f3n de datos y control de acceso basado en roles. Herramientas de Desarrollo: Proporciona herramientas como Oracle SQL Developer y Oracle Application Express (APEX) para facilitar el desarrollo y la gesti\u00f3n de bases de datos. Compatibilidad con NoSQL: A trav\u00e9s de Oracle Database 21c y versiones posteriores, se integra con modelos de datos NoSQL, permitiendo trabajar con documentos JSON y datos de grafos. Soporte para SQL y PL/SQL: Utiliza SQL como lenguaje de consulta est\u00e1ndar y PL/SQL (Procedural Language/SQL) para el desarrollo de aplicaciones, permitiendo la programaci\u00f3n de l\u00f3gica compleja en la base de datos. Casos de Uso Aplicaciones Empresariales: Ideal para aplicaciones cr\u00edticas en sectores como finanzas, salud y telecomunicaciones. Data Warehousing: Adecuado para la consolidaci\u00f3n y an\u00e1lisis de grandes vol\u00famenes de datos. E-commerce: Soporta plataformas de comercio electr\u00f3nico con alta carga de transacciones. Conclusi\u00f3n Oracle Database es una soluci\u00f3n poderosa y vers\u00e1til para la gesti\u00f3n de datos en entornos empresariales. Su capacidad para manejar grandes vol\u00famenes de informaci\u00f3n, junto con caracter\u00edsticas de seguridad y disponibilidad, lo convierte en una opci\u00f3n preferida para organizaciones que requieren un SGBD robusto y confiable.","title":"Oracle"},{"location":"bbdd/sgbd-rel/postgresql/oracle/#definicion","text":"Oracle Database es un sistema gestor de bases de datos relacional (SGBD) desarrollado por Oracle Corporation. Es conocido por su robustez, escalabilidad y amplia gama de caracter\u00edsticas que lo convierten en una opci\u00f3n popular para empresas de todos los tama\u00f1os.","title":"Definici\u00f3n"},{"location":"bbdd/sgbd-rel/postgresql/oracle/#caracteristicas-principales","text":"Modelo Relacional: Oracle utiliza un modelo relacional, lo que significa que los datos se organizan en tablas con filas y columnas. Esto permite una f\u00e1cil estructuraci\u00f3n y recuperaci\u00f3n de datos. Transacciones Seguras: Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad), asegurando que las operaciones sean completas y fiables. Escalabilidad: Oracle puede manejar grandes vol\u00famenes de datos y un alto n\u00famero de usuarios concurrentes, lo que lo hace adecuado para aplicaciones empresariales cr\u00edticas. Alta Disponibilidad: Incluye caracter\u00edsticas como Oracle Real Application Clusters (RAC), que permiten que m\u00faltiples servidores trabajen juntos, asegurando que la base de datos est\u00e9 disponible incluso si uno de los servidores falla. Seguridad Avanzada: Ofrece robustas caracter\u00edsticas de seguridad, incluyendo autenticaci\u00f3n de usuarios, encriptaci\u00f3n de datos y control de acceso basado en roles. Herramientas de Desarrollo: Proporciona herramientas como Oracle SQL Developer y Oracle Application Express (APEX) para facilitar el desarrollo y la gesti\u00f3n de bases de datos. Compatibilidad con NoSQL: A trav\u00e9s de Oracle Database 21c y versiones posteriores, se integra con modelos de datos NoSQL, permitiendo trabajar con documentos JSON y datos de grafos. Soporte para SQL y PL/SQL: Utiliza SQL como lenguaje de consulta est\u00e1ndar y PL/SQL (Procedural Language/SQL) para el desarrollo de aplicaciones, permitiendo la programaci\u00f3n de l\u00f3gica compleja en la base de datos.","title":"Caracter\u00edsticas Principales"},{"location":"bbdd/sgbd-rel/postgresql/oracle/#casos-de-uso","text":"Aplicaciones Empresariales: Ideal para aplicaciones cr\u00edticas en sectores como finanzas, salud y telecomunicaciones. Data Warehousing: Adecuado para la consolidaci\u00f3n y an\u00e1lisis de grandes vol\u00famenes de datos. E-commerce: Soporta plataformas de comercio electr\u00f3nico con alta carga de transacciones.","title":"Casos de Uso"},{"location":"bbdd/sgbd-rel/postgresql/oracle/#conclusion","text":"Oracle Database es una soluci\u00f3n poderosa y vers\u00e1til para la gesti\u00f3n de datos en entornos empresariales. Su capacidad para manejar grandes vol\u00famenes de informaci\u00f3n, junto con caracter\u00edsticas de seguridad y disponibilidad, lo convierte en una opci\u00f3n preferida para organizaciones que requieren un SGBD robusto y confiable.","title":"Conclusi\u00f3n"}]}